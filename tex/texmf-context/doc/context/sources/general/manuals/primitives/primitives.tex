% language=us runpath=texruns:manuals/primitives

% \enableexperiments[fonts.compact]
% \enableexperiments[fonts.accurate]
% \tracepositions

% The usual time stamp. This written while listening intermized to Fish (just ran
% into), Lazulli (some yt videos too, looking forward to a next live act) and
% because this all is boring checking out Sarah Coopers channel for new DT syncs
% every few hours. (Picking up writing this manual in 2023 makes me realize how
% time flies.)

% When you feel unhappy about the lack of detail in this manual, just keep in mind
% that you cannot really demand anything from volunteers: just hope for more (or
% pay for it). Friendly comments and corrections are of course always welcome. As
% we like what we're doing here, it all might eventually evolve to perfection, stay
% tuned.
%
% Hans Hagen | j.hagen @ xs4all . nl | ntg-context @ ntg . nl

\usemodule[system-syntax]
\usemodule[article-basic]
\usemodule[abbreviations-logos]
\usemodule[scite]

\definecolor[maincolor][darkblue]
\definecolor[primcolor][darkblue]
\definecolor[nonecolor][darkgray]

\setuptyping
  [option=tex]

\setuptype
  [option=tex]

\setuphead
  [subject]
  [color=maincolor]

\definehead
  [newprimitive]
  [subsection]
  [color=maincolor]

\definehead
  [oldprimitive]
  [subsection]
  [color=nonecolor]

\setuplist
  [newprimitive]
  [textcolor=maincolor]

\setuplist
  [oldprimitive]
  [textcolor=nonecolor]

% We use the next one because we want to check what has been done. In a document
% like this using \type {\foo} makes more sense.

\protected\def\prm#1%
% {\doifmode{*bodypart}{\index{\tex{#1}}}\tex{#1}}
  {\ifmode{*bodypart}\index{\tex{#1}}\fi\tex{#1}}

\protected\def\stx#1%
  {\ctxlua{moduledata.engine.specification("#1")}} % only for checking

% This is why we need to tag bodymatter.

\starttext

\startbodymatter

\pushoverloadmode

\startMPpage
    fill Page
        withcolor "darkgray" ;
    draw textext("\sstf {\white new} primitives")
        xysized (.9bbwidth(Page),bbheight(Page)-2cm)
        shifted center Page
        withcolor "maincolor" ;
    draw textext.ulft("\sstf in luametatex")
        xysized (.9bbwidth(Page)/3,(bbheight(Page)-2cm)/6)
        shifted center lrcorner Page
        shifted (-.1bbwidth(Page),.05bbwidth(Page))
        withcolor "white" ;
    setbounds currentpicture to Page ;
\stopMPpage

\startsubject[title={Introduction}]

Here I will discuss some of the new primitives in \LUATEX\ and \LUAMETATEX, the
later being a successor that permits the \CONTEXT\ folks to experiment with new
features. The order is arbitrary. When you compare \LUATEX\ with \PDFTEX, there
are actually quite some differences. Some primitives that \PDFTEX\ introduced
have been dropped in \LUATEX\ because they can be done better in \LUA. Others
have been promoted to core primitives that no longer have a \type {pdf} prefix.
Then there are lots of new primitives, some introduce new concepts, some are a
side effect of for instance new math font technologies, and then there are those
that are handy extensions to the macro language. The \LUAMETATEX\ engine drops
quite some primitives, like those related to \PDFTEX\ specific font or backend
features. It also adds some new primitives, mostly concerning the macro language.

We also discuss the primitives that fit into the macro programming scope that are
present in traditional \TEX\ and \ETEX\ but there are for sure better of
descriptions out there already. Primitives that relate to typesetting, like those
controlling math, fonts, boxes, attributes, directions, catcodes, \LUA\
(functions) etc are not discussed here.

There are for instance primitives to create aliases to low level registers like
counters and dimensions, as well as other (semi|-|numeric) quantities like
characters, but normally these are wrapped into high level macros so that
definitions can't clash too much. Numbers, dimensions etc can be advanced,
multiplied and divided and there is a simple expression mechanism to deal with
them. These are not discussed here.

\startcolumns
    \placelist
      [newprimitive,oldprimitive]
      [alternative=c]
\stopcolumns

In this document the section titles that discuss the \color [nonecolor] {original
\TEX\ and \ETEX\ primitives} have a different color those explaining the \color
[primcolor] {\LUATEX\ and \LUAMETATEX\ primitives}.

Primitives that extend typesetting related functionality, provide control over
subsystems (like math), allocate additional data types and resources, deal with
fonts and languages, manipulate boxes and glyphs, etc.\ are not discussed here.
In this document we concentrate on the programming aspects.

% {\em Some new primitives in this list might be forgotten or already became
% obsolete. Let me know if you run into one.}

\stopsubject

% When writing this manual I also decided to merge some of the condition related
% code so that it dealt a bit more natural with the newer features. A usual side
% effects if writing manuals.

\startsubject[title=Primitives]

% \startoldprimitive[title={\prm { }}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {-}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {/}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {Uabove}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Uabovewithdelims}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Uatop}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Uatopwithdelims}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Uchar}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Udelcode}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Udelimited}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Udelimiter}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Udelimiterover}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Udelimiterunder}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Uhextensible}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Uleft}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathaccent}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathaccentbasedepth}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathaccentbaseheight}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathaccentbottomovershoot}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathaccentbottomshiftdown}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathaccentextendmargin}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathaccentsuperscriptdrop}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathaccentsuperscriptpercent}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathaccenttopovershoot}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathaccenttopshiftup}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathaccentvariant}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathadapttoleft}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathadapttoright}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathaxis}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathbottomaccentvariant}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathchar}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathcharclass}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathchardef}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathcharfam}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathcharslot}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathclass}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathcode}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathconnectoroverlapmin}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathdegreevariant}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathdelimiterextendmargin}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathdelimiterovervariant}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathdelimiterpercent}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathdelimitershortfall}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathdelimiterundervariant}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathdenominatorvariant}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathdict}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathdictdef}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathdiscretionary}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathextrasubpreshift}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathextrasubprespace}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathextrasubshift}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathextrasubspace}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathextrasuppreshift}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathextrasupprespace}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathextrasupshift}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathextrasupspace}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathflattenedaccentbasedepth}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathflattenedaccentbaseheight}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathflattenedaccentbottomshiftdown}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathflattenedaccenttopshiftup}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathfractiondelsize}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathfractiondenomdown}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathfractiondenomvgap}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathfractionnumup}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathfractionnumvgap}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathfractionrule}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathfractionvariant}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathhextensiblevariant}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathlimitabovebgap}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathlimitabovekern}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathlimitabovevgap}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathlimitbelowbgap}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathlimitbelowkern}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathlimitbelowvgap}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathlimits}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathnoaxis}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathnolimits}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathnolimitsubfactor}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathnolimitsupfactor}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathnumeratorvariant}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathopenupdepth}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathopenupheight}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathoperatorsize}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathoverbarkern}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathoverbarrule}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathoverbarvgap}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathoverdelimiterbgap}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathoverdelimitervariant}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathoverdelimitervgap}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathoverlayaccentvariant}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathoverlinevariant}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathphantom}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathpresubshiftdistance}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathpresupshiftdistance}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathprimeraise}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathprimeraisecomposed}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathprimeshiftdrop}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathprimeshiftup}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathprimespaceafter}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathprimevariant}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathprimewidth}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathquad}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathradicaldegreeafter}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathradicaldegreebefore}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathradicaldegreeraise}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathradicalextensibleafter}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathradicalextensiblebefore}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathradicalkern}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathradicalrule}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathradicalvariant}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathradicalvgap}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathruledepth}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathruleheight}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathskeweddelimitertolerance}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathskewedfractionhgap}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathskewedfractionvgap}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathsource}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathspaceafterscript}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathspacebeforescript}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathstackdenomdown}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathstacknumup}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathstackvariant}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathstackvgap}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathsubscriptvariant}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathsubshiftdistance}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathsubshiftdown}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathsubshiftdrop}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathsubsupshiftdown}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathsubsupvgap}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathsubtopmax}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathsupbottommin}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathsuperscriptvariant}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathsupshiftdistance}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathsupshiftdrop}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathsupshiftup}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathsupsubbottommax}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathtopaccentvariant}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathunderbarkern}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathunderbarrule}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathunderbarvgap}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathunderdelimiterbgap}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathunderdelimitervariant}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathunderdelimitervgap}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathunderlinevariant}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathuseaxis}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathvextensiblevariant}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathvoid}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathxscale}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umathyscale}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Umiddle}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Unosubprescript}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Unosubscript}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Unosuperprescript}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Unosuperscript}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Uoperator}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Uover}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Uoverdelimiter}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Uoverwithdelims}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Uprimescript}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Uradical}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Uright}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Uroot}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Urooted}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Ushiftedsubprescript}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Ushiftedsubscript}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Ushiftedsuperprescript}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Ushiftedsuperscript}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Uskewed}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Uskewedwithdelims}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Ustack}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Ustartdisplaymath}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Ustartmath}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Ustartmathmode}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Ustopdisplaymath}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Ustopmath}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Ustopmathmode}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Ustretched}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Ustretchedwithdelims}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Ustyle}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Usubprescript}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Usubscript}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Usuperprescript}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Usuperscript}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Uunderdelimiter}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {Uvextensible}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {above}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {abovedisplayshortskip}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {abovedisplayskip}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {abovewithdelims}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {accent}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {additionalpageskip}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {adjdemerits}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {adjustspacing}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {adjustspacingshrink}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {adjustspacingstep}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {adjustspacingstretch}}]
% \stopnewprimitive

\startoldprimitive[title={\prm {advance}}]

Advances the given register by an also given value:

\starttyping
\advance\scratchdimen      10pt
\advance\scratchdimen      by 3pt
\advance\scratchcounterone \zerocount
\advance\scratchcounterone \scratchcountertwo
\stoptyping

The \type {by} keyword is optional.

\stopoldprimitive

\startnewprimitive[title={\prm {advanceby}}]

This is slightly more efficient variant of \prm {advance} that doesn't look for
\type {by} and therefore, if one is missing, doesn't need to push back the last
seen token. Using \prm {advance} with \type {by} is nearly as efficient but takes
more tokens.

\stopnewprimitive

\startnewprimitive[title={\prm {afterassigned}}]

The \prm {afterassignment} primitive stores a token to be injected (and thereby
expanded) after an assignment has happened. Unlike \prm {aftergroup}, multiple
calls are not accumulated, and changing that would be too incompatible. This is
why we have \prm {afterassigned}, which can be used to inject a bunch of
tokens. But in order to be consistent this one is also not accumulative.

\startbuffer
\afterassigned{done}%
\afterassigned{{\bf done}}%
\scratchcounter=123
\stopbuffer

\typebuffer

results in: \inlinebuffer\ being typeset.

\stopnewprimitive

\startoldprimitive[title={\prm {afterassignment}}]

The token following \prm {afterassignment}, a traditional \TEX\ primitive, is
saved and gets injected (and then expanded) after a following assignment took
place.

\startbuffer
\afterassignment !\def\MyMacro {}\quad
\afterassignment !\let\MyMacro ?\quad
\afterassignment !\scratchcounter 123\quad
\afterassignment !%
\afterassignment ?\advance\scratchcounter by 1
\stopbuffer

\typebuffer

The \prm {afterassignment}s are not accumulated, the last one wins:

{\getbuffer}

\stopoldprimitive

\startoldprimitive[title={\prm {aftergroup}}]

The traditional \TEX\ \prm {aftergroup} primitive stores the next token and
expands that after the group has been closed.

\startbuffer
before{ ! \aftergroup a\aftergroup f\aftergroup t\aftergroup e\aftergroup r}
\stopbuffer

Multiple \prm {aftergroup}s are combined:

\typebuffer

\getbuffer

\stopoldprimitive

\startnewprimitive[title={\prm {aftergrouped}}]

The in itself powerful \prm {aftergroup} primitives works quite well, even
if you need to do more than one thing: you can either use it multiple times, or
you can define a macro that does multiple things and apply that after the group.
However, you can avoid that by using this primitive which takes a list of tokens.

\startbuffer
regular
\bgroup
\aftergrouped{regular}%
\bf bold
\egroup
\stopbuffer

\typebuffer

Because it happens after the group, we're no longer typesetting in bold.

{\getbuffer}

\stopnewprimitive

\startnewprimitive[title={\prm {aliased}}]

This primitive is part of the overload protection subsystem where control sequences
can be tagged.

\startbuffer
\permanent\def\foo{FOO}
          \let\ofo\foo
\aliased  \let\oof\foo

\meaningasis\foo
\meaningasis\ofo
\meaningasis\oof
\stopbuffer

\typebuffer

gives:

\startlines \tt
\getbuffer
\stoplines

When a something is \prm {let} the \quote {permanent}, \quote {primitive} and
\quote {immutable} flags are removed but the \prm {aliased} prefix retains
them.

\startbuffer
\let\relaxed\relax

\meaningasis\relax
\meaningasis\relaxed
\stopbuffer

\typebuffer

So in this example the \type {\relaxed} alias is not flagged as primitive:

\startlines \tt
\getbuffer
\stoplines

\stopnewprimitive

% \startnewprimitive[title={\prm {aligncontent}}]
% \stopnewprimitive

\startnewprimitive[title={\prm {alignmark}}]

When you have the \type {#} not set up as macro parameter character cq.\ align
mark, you can use this primitive instead. The same rules apply with respect to
multiple such tokens in (nested) macros and alignments.

\stopnewprimitive

% \startnewprimitive[title={\prm {alignmentcellsource}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {alignmentwrapsource}}]
% \stopnewprimitive

\startnewprimitive[title={\prm {aligntab}}]

When you have the \type {&} not set up as align tab, you can use this primitive
instead. The same rules apply with respect to multiple such tokens in (nested)
macros and alignments.

\stopnewprimitive

% \startnewprimitive[title={\prm {allcrampedstyles}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {alldisplaystyles}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {allmainstyles}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {allmathstyles}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {allscriptscriptstyles}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {allscriptstyles}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {allsplitstyles}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {alltextstyles}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {alluncrampedstyles}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {allunsplitstyles}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {amcode}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {associateunit}}]
%     TODO
% \stopnewprimitive

\startnewprimitive[title={\prm {atendoffile}}]

The \prm {everyeof} primitive is kind of useless because you don't know if a file
(which can be a tokenlist processed as pseudo file) itself includes a file, which
then results in nested application of this token register. One way around this is:

\startbuffer
\atendoffile\SomeCommand
\stopbuffer

\typebuffer

This acts on files the same way as \prm {atendofgroup} does. Multiple calls will
be accumulated and are bound to the current file.

\stopnewprimitive

\startnewprimitive[title={\prm {atendoffiled}}]

This is the multi token variant of \prm {atendoffile}. Multiple invocations are
accumulated and by default prepended to the existing list. As with grouping this
permits proper nesting. You can force an append by the optional keyword {reverse}.

\stopnewprimitive

\startnewprimitive[title={\prm {atendofgroup}}]

The token provided will be injected just before the group ends. Because
these tokens are collected, you need to be aware of possible interference
between them. However, normally this is managed by the macro package.

\startbuffer
\bgroup
\atendofgroup\unskip
\atendofgroup )%
(but it works okay
\egroup
\stopbuffer

\typebuffer

Of course these effects can also be achieved by combining (extra) grouping with
\prm {aftergroup} calls, so this is more a convenience primitives than a real
necessity: {\inlinebuffer}, as proven here.

\stopnewprimitive

\startnewprimitive[title={\prm {atendofgrouped}}]

This is the multi token variant of \prm {atendofgroup}. Of course the next
example is somewhat naive when it comes to spacing and so, but it shows the
purpose.

\startbuffer
\bgroup
\atendofgrouped{\bf QED}%
\atendofgrouped{ (indeed)}%
This sometimes looks nicer.
\egroup
\stopbuffer

\typebuffer

Multiple invocations are accumulated: {\inlinebuffer}.

\stopnewprimitive

% \startoldprimitive[title={\prm {atop}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {atopwithdelims}}]
% \stopoldprimitive

\startnewprimitive[title={\prm {attribute}}]

The following sets an attribute(register) value:

\starttyping
\attribute 999 = 123
\stoptyping

An attribute is unset by assigning \the \attributeunsetvalue\ to it. A user needs
to be aware of attributes being used now and in the future of a macro package and
setting them this way is very likely going to interfere.

\stopnewprimitive

\startnewprimitive[title={\prm {attributedef}}]

This primitive can be used to relate a control sequence to an attribute register
and can be used to implement a mechanism for defining unique ones that won't
interfere. As with other registers: leave management to the macro package in
order to avoid unwanted side effects!

\stopnewprimitive

% \startnewprimitive[title={\prm {automaticdiscretionary}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {automatichyphenpenalty}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {automigrationmode}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {autoparagraphmode}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {badness}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {baselineskip}}]
% \stopoldprimitive

\startoldprimitive[title={\prm {batchmode}}]

This command disables (error) messages which can safe some runtime in situations
where \TEX's character|-|by|-|character log output impacts runtime. It only makes
sense in automated workflows where one doesn't look at the log anyway.

\stopoldprimitive

\startnewprimitive[title={\prm {begincsname}}]

The next code creates a control sequence token from the given serialized tokens:

\starttyping
\csname mymacro\endcsname
\stoptyping

When \type {\mymacro} is not defined a control sequence will be created with the
meaning \prm {relax}. A side effect is that a test for its existence might fail
because it now exists. The next sequence will {\em not} create an controil
sequence:

\starttyping
\begincsname mymacro\endcsname
\stoptyping

This actually is kind of equivalent to:

\starttyping
\ifcsname mymacro\endcsname
    \csname mymacro\endcsname
\fi
\stoptyping

\stopnewprimitive

\startoldprimitive[title={\prm {begingroup}}]

This primitive starts a group and has to be ended with \prm {endgroup}. See \prm
{beginsimplegroup} for more info.

\stopoldprimitive

\startnewprimitive[title={\prm {beginlocalcontrol}}]

Once \TEX\ is initialized it will enter the main loop. In there certain commands
trigger a function that itself can trigger further scanning and functions. In
\LUAMETATEX\ we can have local main loops and we can either enter it from the
\LUA\ end (which we don't discuss here) or at the \TEX\ end using this primitive.

\startbuffer
\scratchcounter100

\edef\whatever{
    a
    \beginlocalcontrol
        \advance\scratchcounter 10
        b
    \endlocalcontrol
    \beginlocalcontrol
        c
    \endlocalcontrol
    d
    \advance\scratchcounter 10
}

\the\scratchcounter
\whatever
\the\scratchcounter
\stopbuffer

\typebuffer

A bit of close reading probably gives an impression of what happens here:

{\getbuffer}

The local loop can actually result in material being injected in the current node
list. However, where normally assignments are not taking place in an \prm
{edef}, here they are applied just fine. Basically we have a local \TEX\ job, be
it that it shares all variables with the parent loop.

\stopnewprimitive

\startnewprimitive[title={\prm {beginmathgroup}}]

In math mode grouping with \prm {begingroup} and \prm {endgroup} in some cases
works as expected, but because the math input is converted in a list that gets
processed later some settings can become persistent, like changes in style or
family. The engine therefore provides the alternatives \prm {beginmathgroup} and
\prm {endmathgroup} that restore some properties.

\stopnewprimitive

\startnewprimitive[title={\prm {beginsimplegroup}}]

The original \TEX\ engine distinguishes two kind of grouping that at the user end
show up as:

\starttyping
\begingroup \endgroup
\bgroup \egroup { }
\stoptyping

where the last two pairs are equivalent unless the scanner explicitly wants to see a
left and|/|or right brace and not an equivalent. For the sake of simplify we use
the aliases here. It is not possible to mix these pairs, so:

\starttyping
\bgroup xxx\endgroup
\begingroup xxx\egroup
\stoptyping

will in both cases issue an error. This can make it somewhat hard to write generic
grouping macros without somewhat dirty trickery. The way out is to use the generic
group opener \prm {beginsimplegroup}.

Internally \LUAMETATEX\ is aware of  what group it currently is dealing with and
there we distinguish:

\starttabulate[||||]
\NC simple group      \NC \type {\bgroup}           \NC \type {\egroup} \NC \NR
\NC semi simple group \NC \type {\begingroup}       \NC \type {\endgroup} \type {\endsimplegroup} \NC \NR
\NC also simple group \NC \type {\beginsimplegroup} \NC \type {\egroup} \type {\endgroup} \type {\endsimplegroup} \NC \NR
\NC math simple group \NC \type {\beginmathgroup}   \NC \type {\endmathgroup} \NC \NR
\stoptabulate

This means that you can say:

\starttyping
\beginsimplegroup xxx\endsimplegroup
\beginsimplegroup xxx\endgroup
\beginsimplegroup xxx\egroup
\stoptyping

So a group started with \prm {beginsimplegroup} can be finished in three ways
which means that the user (or calling macro) doesn't have take into account what
kind of grouping was used to start with. Normally usage of this primitive is
hidden in macros and not something the user has to be aware of.

\stopnewprimitive

% \startoldprimitive[title={\prm {belowdisplayshortskip}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {belowdisplayskip}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {binoppenalty}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {botmark}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {botmarks}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {boundary}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {box}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {boxadapt}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {boxanchor}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {boxanchors}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {boxattribute}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {boxdirection}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {boxfreeze}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {boxgeometry}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {boxlimitate}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {boxmaxdepth}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {boxorientation}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {boxrepack}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {boxshift}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {boxshrink}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {boxsource}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {boxstretch}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {boxtarget}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {boxtotal}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {boxvadjust}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {boxxmove}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {boxxoffset}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {boxymove}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {boxyoffset}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {brokenpenalty}}]
% \stopoldprimitive

\startoldprimitive[title={\prm {catcode}}]

Every character can be put in a category, but this is typically
something that the macro package manages because changes can affect
behavior. Also, once passed as an argument, the catcode of a character
is frozen. There are 16 different values:

\starttabulate[|l|c|l|c|]
\NC \type {\escapecatcode     } \NC \the\escapecatcode
\NC \type {\begingroupcatcode } \NC \the\begingroupcatcode  \NC \NR
\NC \type {\endgroupcatcode   } \NC \the\endgroupcatcode
\NC \type {\mathshiftcatcode  } \NC \the\mathshiftcatcode   \NC \NR
\NC \type {\alignmentcatcode  } \NC \the\alignmentcatcode
\NC \type {\endoflinecatcode  } \NC \the\endoflinecatcode   \NC \NR
\NC \type {\parametercatcode  } \NC \the\parametercatcode
\NC \type {\superscriptcatcode} \NC \the\superscriptcatcode \NC \NR
\NC \type {\subscriptcatcode  } \NC \the\subscriptcatcode
\NC \type {\ignorecatcode     } \NC \the\ignorecatcode      \NC \NR
\NC \type {\spacecatcode      } \NC \the\spacecatcode
\NC \type {\lettercatcode     } \NC \the\lettercatcode      \NC \NR
\NC \type {\othercatcode      } \NC \the\othercatcode
\NC \type {\activecatcode     } \NC \the\activecatcode      \NC \NR
\NC \type {\commentcatcode    } \NC \the\commentcatcode
\NC \type {\invalidcatcode    } \NC \the\invalidcatcode     \NC \NR
\stoptabulate

The first column shows the constant that \CONTEXT\ provides and the
name indicates the purpose. Here are two examples:

\starttyping
\catcode123=\begingroupcatcode
\catcode125=\endgroupcatcode
\stoptyping

\stopoldprimitive

\startnewprimitive[title={\prm {catcodetable}}]

The catcode table with the given index will become active.

\stopnewprimitive

\startnewprimitive[title={\prm {cdef}}]

This primitive is like \prm {edef} but in some usage scenarios is slightly
more efficient because (delayed) expansion is ignored which in turn saves
building a temporary token list.

\startbuffer
\edef\FooA{this is foo} \meaningfull\FooA\crlf
\cdef\FooB{this is foo} \meaningfull\FooB\par
\stopbuffer

\typebuffer {\tttf \getbuffer}

\stopnewprimitive

\startnewprimitive[title={\prm {cdefcsname}}]

This primitive is like \prm {edefcsame} but in some usage scenarios is slightly
more efficient because (delayed) expansion is ignored which in turn saves
building a temporary token list.

\startbuffer
\edefcsname FooA\endcsname{this is foo} \meaningasis\FooA\crlf
\cdefcsname FooB\endcsname{this is foo} \meaningasis\FooB\par
\stopbuffer

\typebuffer {\tttf \getbuffer}

\stopnewprimitive

% \startnewprimitive[title={\prm {cfcode}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {char}}]
% \stopoldprimitive

\startoldprimitive[title={\prm {chardef}}]

The following definition relates a control sequence to a specific character:

\starttyping
\chardef\copyrightsign"A9
\stoptyping

However, because in a context where a number is expected, such a \prm {chardef}
is seen as valid number, there was a time when this primitive was used to define
constants without overflowing the by then limited pool of count registers. In
\ETEX\ aware engines this was less needed, and in \LUAMETATEX\ we have \prm
{integerdef} as a more natural candidate.

\stopoldprimitive

% \startoldprimitive[title={\prm {cleaders}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {clearmarks}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {clubpenalties}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {clubpenalty}}]
% \stopoldprimitive

\startnewprimitive[title={\prm {constant}}]

This prefix tags a macro (without arguments) as being constant. The main
consequence is that in some cases expansion gets delayed which gives a little
performance boost and less (temporary) memory usage, for instance in \type
{\csname} like scenarios.

\stopnewprimitive

\startnewprimitive[title={\prm {constrained}}]

See previous section about \prm {retained}.

\stopnewprimitive

% \startoldprimitive[title={\prm {copy}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {copymathatomrule}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {copymathparent}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {copymathspacing}}]
% \stopnewprimitive

\startoldprimitive[title={\prm {count}}]

This accesses a count register by index. This is kind of \quote {not done} unless
we changed \prm you do it local and make sure that it doesn't influence macros
that you call.

\starttyping
\count4023=10
\stoptyping

In standard \TEX\ the first 10 counters are special because they get reported to
the console, and \type {\count0} is then assumed to be the page counter.

\stopoldprimitive

\startoldprimitive[title={\prm {countdef}}]

This primitive relates a control sequence to a count register. Compare this to
the example in the previous section.

\starttyping
\countdef\MyCounter4023
\MyCounter=10
\stoptyping

However, this is also \quote {not done}. Instead one should use the allocator that
the macro package provides.

\starttyping
\newcount\MyCounter
\MyCounter=10
\stoptyping

In \LUAMETATEX\ we also have integers that don't rely on registers. These are
assigned by the primitive \prm {integerdef}:

\starttyping
\integerdef\MyCounterA 10
\stoptyping

Or better \type {\newinteger}.

\starttyping
\newinteger\MyCounterB
\MyCounterN10
\stoptyping

There is a lowlevel manual on registers.

\stopoldprimitive

% \startoldprimitive[title={\prm {cr}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {crampeddisplaystyle}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {crampedscriptscriptstyle}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {crampedscriptstyle}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {crampedtextstyle}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {crcr}}]
% \stopoldprimitive

\startnewprimitive[title={\prm {csactive}}]

Because \LUATEX\ (and \LUAMETATEX) are \UNICODE\ engines active characters are
implemented a bit differently. They don't occupy a eight bit range of characters
but are stored as control sequence with a special prefix \type {U+FFFF} which
never shows up in documents. The \prm {csstring} primitive injects the name of a
control sequence without leading escape character, the \prm {csactive} injects
the internal name of the following (either of not active) character. As we cannot
display the prefix: \type {\csactive~} will inject the \UTF\ sequences for \type
{U+FFFF} and \type {U+007E}, so here we get the bytes \type {EFBFBF7E}. Basically
the next token is preceded by \prm {string}, so when you don't provide a
character you are in for a surprise.

\stopnewprimitive

\startoldprimitive[title={\prm {csname}}]

This original \TEX\ primitive starts the construction of a control sequence
reference. It does a lookup and when no sequence with than name is found, it will
create a hash entry and defaults its meaning to \prm {relax}.

\starttyping
\csname letters and other characters\endcsname
\stoptyping

\stopoldprimitive

\startnewprimitive[title={\prm {csstring}}]

This primitive returns the name of the control sequence given without the leading
escape character (normally a backslash). Of course you could strip that character
with a simple helper but this is more natural.

\startbuffer
\csstring\mymacro
\stopbuffer

\typebuffer

We get the name, not the meaning: {\tt \inlinebuffer}.

\stopnewprimitive

\startoldprimitive[title={\prm {currentgrouplevel}}]

\startbuffer
[\the\currentgrouplevel] \bgroup
    [\the\currentgrouplevel] \bgroup
        [\the\currentgrouplevel]
    \egroup [\the\currentgrouplevel]
\egroup [\the\currentgrouplevel]
\stopbuffer

The next example gives: \inlinebuffer.

\typebuffer

\stopoldprimitive

\startoldprimitive[title={\prm {currentgrouptype}}]

\startbuffer
[\the\currentgrouptype] \bgroup
    [\the\currentgrouptype] \begingroup
        [\the\currentgrouptype]
    \endgroup [\the\currentgrouptype]
    [\the\currentgrouptype] \beginmathgroup
        [\the\currentgrouptype]
    \endmathgroup [\the\currentgrouptype]
[\the\currentgrouptype] \egroup
\stopbuffer

The next example gives: \inlinebuffer.

\typebuffer

The possible values depend in the engine and for \LUAMETATEX\ they are:

\startluacode
context.startcolumns { n = 4 }
context.starttabulate { "|r|l|" }
for i=0,#tex.groupcodes do
    context.NC() context(i)
    context.NC() context(tex.groupcodes[i])
    context.NC() context.NR()
end
context.stoptabulate()
context.stopcolumns()
\stopluacode

\stopoldprimitive

\startoldprimitive[title={\prm {currentifbranch}}]

\startbuffer
[\the\currentifbranch] \iftrue
    [\the\currentifbranch] \iffalse
        [\the\currentifbranch]
    \else
        [\the\currentifbranch]
    \fi [\the\currentifbranch]
\fi [\the\currentifbranch]
\stopbuffer

The next example gives: \inlinebuffer.

\typebuffer

So when in the \quote {then} branch we get plus one and when in the \quote {else}
branch we end up with a minus one.

\stopoldprimitive

\startoldprimitive[title={\prm {currentiflevel}}]

\startbuffer
[\the\currentiflevel] \iftrue
    [\the\currentiflevel]\iftrue
        [\the\currentiflevel] \iftrue
            [\the\currentiflevel]
        \fi [\the\currentiflevel]
    \fi [\the\currentiflevel]
\fi [\the\currentiflevel]
\stopbuffer

The next example gives: \inlinebuffer.

\typebuffer

\stopoldprimitive

\startoldprimitive[title={\prm {currentiftype}}]

\startbuffer
[\the\currentiftype] \iftrue
    [\the\currentiftype]\iftrue
        [\the\currentiftype] \iftrue
            [\the\currentiftype]
        \fi [\the\currentiftype]
    \fi [\the\currentiftype]
\fi [\the\currentiftype]
\stopbuffer

The next example gives: \inlinebuffer.

\typebuffer

The values are engine dependent:

\startluacode
local t = tex.getiftypes()
context.startcolumns { n = 5 }
context.starttabulate { "|r|l|" }
for i=0,#tex.groupcodes do
    context.NC() context(i)
    context.NC() context(t[i])
    context.NC() context.NR()
end
context.stoptabulate()
context.stopcolumns()
\stopluacode

\stopoldprimitive

\startnewprimitive[title={\prm {currentloopiterator}}]

Here we show the different expanded loop variants:

\startbuffer
\edef\testA{\expandedloop  1 10 1{!}}
\edef\testB{\expandedrepeat  10  {!}}
\edef\testC{\expandedendless     {\ifnum\currentloopiterator>10 \quitloop\else !\fi}}
\edef\testD{\expandedendless     {\ifnum#I>10 \quitloop\else !\fi}}
\stopbuffer

\typebuffer \getbuffer

All these give the same result:

\startlines \tt
\meaningasis\testA
\meaningasis\testB
\meaningasis\testC
\meaningasis\testD
\stoplines

The \type {#I} is a shortcut to the current loop iterator; other shortcuts are
\type {#P} for the parent iterator value and \type {#G} for the grand parent.

\stopnewprimitive

\startnewprimitive[title={\prm {currentloopnesting}}]

This integer reports how many nested loops are currently active. Of course in
practice the value only has meaning when you know at what outer level your nested
loop started.

\stopnewprimitive

% \startnewprimitive[title={\prm {currentmarks}}]
% \stopnewprimitive

\startoldprimitive[title={\prm {currentstacksize}}]

This is more diagnostic feature than a useful one but we show it anyway. There is
some basic overhead when we enter a group:

\startbuffer
\bgroup [\the\currentstacksize]
    \bgroup [\the\currentstacksize]
        \bgroup [\the\currentstacksize]
        [\the\currentstacksize] \egroup
    [\the\currentstacksize] \egroup
[\the\currentstacksize] \egroup
\stopbuffer

\typebuffer \getbuffer

As soon as we define something or change a value, the stack gets populated by
information needed for recovery after the group ends.

\startbuffer
\bgroup [\the\currentstacksize]
    \scratchcounter 1
    \bgroup [\the\currentstacksize]
        \scratchdimen 1pt
        \scratchdimen 2pt
        \bgroup [\the\currentstacksize]
            \scratchcounter 2
            \scratchcounter 3
        [\the\currentstacksize] \egroup
    [\the\currentstacksize] \egroup
[\the\currentstacksize] \egroup
\stopbuffer

\typebuffer \getbuffer

The stack also keeps some state information, for instance when a box is being
built. In \LUAMETATEX\ that is is quite a bit more than in other engines but it
is compensated by more efficient save stack handling elsewhere.

\startbuffer
\hbox \bgroup [\the\currentstacksize]
    \hbox \bgroup [\the\currentstacksize]
        \hbox \bgroup [\the\currentstacksize]
        [\the\currentstacksize] \egroup
    [\the\currentstacksize] \egroup
[\the\currentstacksize] \egroup
\stopbuffer

\typebuffer \getbuffer

\stopoldprimitive

% \startoldprimitive[title={\prm {day}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {dbox}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {deadcycles}}]
% \stopoldprimitive

\startoldprimitive[title={\prm {def}}]

This is the main definition command, as in:

\starttyping
\def\foo{l me}
\stoptyping

with companions like \prm {gdef}, \prm {edef}, \prm {xdef}, etc. and variants
like:

\starttyping
\def\foo#1{... #1...}
\stoptyping

where the hash is used in the preamble and for referencing. More about that can
be found in the low level manual about macros.

\stopoldprimitive

% \startoldprimitive[title={\prm {defaulthyphenchar}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {defaultskewchar}}]
% \stopoldprimitive

\startnewprimitive[title={\prm {defcsname}}]

We now get a series of log clutter avoidance primitives. It's fine if you argue
that they are not really needed, just don't use them.

\starttyping
\expandafter\def\csname MyMacro:1\endcsname{...}
             \defcsname MyMacro:1\endcsname{...}
\stoptyping

The fact that \TEX\ has three (expanded and global) companions can be seen as a
signal that less verbosity makes sense. It's just that macro packages use plenty
of \prm {csname}'s.

\stopnewprimitive

% \startnewprimitive[title={\prm {deferred}}]
%     TODO
% \stopnewprimitive

% \startoldprimitive[title={\prm {delcode}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {delimiter}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {delimiterfactor}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {delimitershortfall}}]
% \stopoldprimitive

\startnewprimitive[title={\prm {detokened}}]

The following token will be serialized into characters with category \quote
{other}.

\startbuffer
\toks0{123}
\def\foo{let's be \relax'd}
\def\oof#1{let's see #1}
\detokened\toks0
\detokened\foo
\detokened\oof
\detokened\setbox
\detokened X
\stopbuffer

\typebuffer

Gives:

\startlines\tt
\getbuffer
\stoplines

Macros with arguments are not shown.

\stopnewprimitive

\startoldprimitive[title={\prm {detokenize}}]

This \ETEX\ primitive turns the content of the provides list will become
characters, kind of verbatim.

\startbuffer
\expandafter\let\expandafter\temp\detokenize{1} \meaning\temp
\expandafter\let\expandafter\temp\detokenize{A} \meaning\temp
\stopbuffer

\typebuffer

\startlines \tttf \getbuffer \stoplines

\stopoldprimitive

\startnewprimitive[title={\prm {detokenized}}]

The following (single) token will be serialized into characters with category
\quote {other}.

\startbuffer
\toks0{123}
\def\foo{let's be \relax'd}
\def\oof#1{let's see #1}
\detokenized\toks0
\detokenized\foo
\detokenized\oof
\detokenized\setbox
\detokenized X
\stopbuffer

\typebuffer

Gives:

\startlines\tt
\getbuffer
\stoplines

It is one of these new primitives that complement others like \prm {detokened}
and such, and they are often mostly useful in experiments of some low level
magic, which made them stay.

\stopnewprimitive

\startoldprimitive[title={\prm {dimen}}]

Like \prm {count} this is a register accessor which is described in more
detail in a low level manual.

\starttyping
\dimen0=10pt
\stoptyping

While \TEX\ has some assumptions with respect to the first ten count registers
(as well as the one that holds the output, normally 255), all dimension registers
are treated equal. However, you need to be aware of clashes with other usage.
Therefore you can best use the predefined scratch registers or define dedicate
ones with the \type {\newdimen} macro.

\stopoldprimitive

\startoldprimitive[title={\prm {dimendef}}]

This primitive is used by the \type {\newdimen} macro when it relates a control
sequence with a specific register. Only use it when you know what you're doing.

\stopoldprimitive

\startnewprimitive[title={\prm {dimensiondef}}]

A variant of \prm {integerdef} is:

\starttyping
\dimensiondef\MyDimen = 1234pt
\stoptyping

The properties are comparable to the ones described in the section \prm
{integerdef}.

\stopnewprimitive

\startoldprimitive[title={\prm {dimexpr}}]

This primitive is similar to of \prm {numexpr} but operates on dimensions
instead. Integer quantities are interpreted as dimensions in scaled points.

\stopoldprimitive

\startnewprimitive[title={\prm {dimexpression}}]

This command is like \prm {numexpression} but results in a dimension instead of
an integer. Where \prm {dimexpr} doesn't like \typ {2 * 10pt} this expression
primitive is quite happy with it.

\stopnewprimitive

\startnewprimitive[title={\prm {directlua}}]

This is the low level interface to \LUA:

\startbuffer
\directlua { tex.print ("Greetings from the lua end!") }
\stopbuffer

Gives: \quotation {\inlinebuffer} as expected. In \LUA\ we have access to all
kind of internals of the engine. In \LUAMETATEX\ the interfaces have been
polished and extended compared to \LUATEX. Although many primitives and
mechanisms were added to the \TEX\ frontend, the main extension interface remains
\LUA. More information can be found in documents that come with \CONTEXT, in
presentations and in articles.

\stopnewprimitive

% \startoldprimitive[title={\prm {discretionary}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {discretionaryoptions}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {displayindent}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {displaylimits}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {displaystyle}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {displaywidowpenalties}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {displaywidowpenalty}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {displaywidth}}]
% \stopoldprimitive

\startoldprimitive[title={\prm {divide}}]

The \prm {divide} operation can be applied to integers, dimensions, float,
attribute and glue quantities. There are subtle rounding differences between
the divisions in expressions and \prm {divide}:

\starttabulate
\NC \type {\scratchcounter1049     \numexpr\scratchcounter/ 10\relax}
\EQ        \scratchcounter1049 \the\numexpr\scratchcounter/ 10\relax
\NC \NR
\NC \type {\scratchcounter1049     \numexpr\scratchcounter: 10\relax}
\EQ        \scratchcounter1049 \the\numexpr\scratchcounter: 10\relax
\NC \NR
\NC \type {\scratchcounter1049 \divide\scratchcounter by 10}
\EQ        \scratchcounter1049 \divide\scratchcounter by 10
                               \the\scratchcounter
\NC \NR
\stoptabulate

The \type {:} divider in \prm {dimexpr} is something that we introduced in
\LUATEX.

\stopoldprimitive

\startnewprimitive[title={\prm {divideby}}]

This is slightly more efficient variant of \prm {divide} that doesn't look for
\type {by}. See previous section.

\stopnewprimitive

% \startoldprimitive[title={\prm {doubleadjdemerits}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {doublehyphendemerits}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {dp}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {dpack}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {dsplit}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {dump}}]
% \stopoldprimitive

\startoldprimitive[title={\prm {edef}}]

This is the expanded version of \prm {def}.

\startbuffer
\def \foo{foo}      \meaning\foo
\def \ofo{\foo\foo} \meaning\ofo
\edef\oof{\foo\foo} \meaning\oof
\stopbuffer

\typebuffer

Because \type {\foo} is unprotected it will expand inside the body definition:

\startlines \tt
\getbuffer
\stoplines

\stopoldprimitive

\startnewprimitive[title={\prm {edefcsname}}]

This is the companion of \prm {edef}:

\starttyping
\expandafter\edef\csname MyMacro:1\endcsname{...}
             \edefcsname MyMacro:1\endcsname{...}
\stoptyping

\stopnewprimitive

\startnewprimitive[title={\prm {expandeddetokenize}}]

This is a companion to \prm {detokenize} that expands its argument:

\startbuffer
\def\foo{12#H3}
\def\oof{\foo}
\detokenize        {\foo} \detokenize        {\oof}
\expandeddetokenize{\foo} \expandeddetokenize{\oof}
\edef\ofo{\expandeddetokenize{\foo}} \meaningless\ofo
\edef\ofo{\expandeddetokenize{\oof}} \meaningless\ofo
\stopbuffer

\typebuffer

This is a bit more convenient than

\starttyping
\detokenize \expandafter {\normalexpanded {\foo}}
\stoptyping

kind of solutions. We get:

\startlines
\getbuffer
\stoplines

\stopnewprimitive

\startnewprimitive[title={\prm {edivide}}]

When expressions were introduced the decision was made to round the divisions which is
incompatible with the way \prm {divide} works. The expression scanners in \LUAMETATEX\
compensates that by providing a \type {:} for integer division. The \prm{ edivide} does
the opposite: it rounds the way expressions do.

\startbuffer
\the\dimexpr .4999pt                     : 2 \relax           =.24994pt
\the\dimexpr .4999pt                     / 2 \relax           =.24995pt
\scratchdimen.4999pt \divide \scratchdimen 2 \the\scratchdimen=.24994pt
\scratchdimen.4999pt \edivide\scratchdimen 2 \the\scratchdimen=.24995pt

\the\numexpr   1001                        : 2 \relax             =500
\the\numexpr   1001                        / 2 \relax             =501
\scratchcounter1001  \divide \scratchcounter 2 \the\scratchcounter=500
\scratchcounter1001  \edivide\scratchcounter 2 \the\scratchcounter=501
\stopbuffer

\typebuffer

Keep in mind that with dimensions we have a fractional part so we actually
rounding applies to the fraction. For that reason we also provide \prm {rdivide}.

\startlines
\getbuffer
\stoplines

\stopnewprimitive

\startnewprimitive[title={\prm {edivideby}}]

This the \type {by}|-|less variant of \prm {edivide}.

\stopnewprimitive

% \startnewprimitive[title={\prm {efcode}}]
% \stopnewprimitive

\startoldprimitive[title={\prm {else}}]

This traditional primitive is part of the condition testing mechanism. When a
condition matches, \TEX\ will continue till it sees an \prm {else} or \prm
{or} or \prm {orelse} (to be discussed later). It will then do a fast skipping
pass till it sees an \prm {fi}.

\stopoldprimitive

% \startoldprimitive[title={\prm {emergencyextrastretch}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {emergencyleftskip}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {emergencyrightskip}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {emergencystretch}}]
% \stopoldprimitive

\startoldprimitive[title={\prm {end}}]

This ends a \TEX\ run, unless of course this primitive is redefined.

\stopoldprimitive

\startoldprimitive[title={\prm {endcsname}}]

This primitive is used in combination with \prm {csname}, \prm {ifcsname} and
\prm {begincsname} where its end the scanning for the to be constructed control
sequence token.

\stopoldprimitive

\startoldprimitive[title={\prm {endgroup}}]

This is the companion of the \prm {begingroup} primitive that opens a group. See
\prm {beginsimplegroup} for more info.

\stopoldprimitive

\startoldprimitive[title={\prm {endinput}}]

The engine can be in different input modes: reading from file, reading from a
token list, expanding a macro, processing something that comes back from \LUA,
etc. This primitive quits reading from file:

\startbuffer
this is seen
\endinput
here we're already quit
\stopbuffer

\typebuffer

There is a catch. This is what the above gives:

\getbuffer

but how about this:

\startbuffer
this is seen
before \endinput after
here we're already quit
\stopbuffer

\typebuffer

Here we get:

\getbuffer

Because a token list is one line, the following works okay:

\starttyping
\def\quitrun{\ifsomething \endinput \fi}
\stoptyping

but in a file you'd have to do this when you quit in a conditional:

\starttyping
\ifsomething
    \expandafter \endinput
\fi
\stoptyping

While the one|-|liner works as expected:

\starttyping
\ifsomething \endinput \fi
\stoptyping

\stopoldprimitive

\startoldprimitive[title={\prm {endlinechar}}]

This is an internal integer register. When set to positive value the character
with that code point will be appended to the line. The current value is \the
\endlinechar. Here is an example:

\startbuffer
\endlinechar\hyphenasciicode
line 1
line 2
\stopbuffer

\typebuffer

\start \getbuffer \stop

If the character is active, the property is honored and the command kicks in. The
maximum value is 127 (the maximum character code a single byte \UTF\ character
can carry.)

\stopoldprimitive

\startnewprimitive[title={\prm {endlocalcontrol}}]

See \prm {beginlocalcontrol}.

\stopnewprimitive

\startnewprimitive[title={\prm {endmathgroup}}]

This primitive is the counterpart of \prm {beginmathgroup}.

\stopnewprimitive

\startnewprimitive[title={\prm {endsimplegroup}}]

This one ends a simple group, see \prm {beginsimplegroup} for an explanation
about grouping primitives.

\stopnewprimitive

\startnewprimitive[title={\prm {enforced}}]

The engine can be set up to prevent overloading of primitives and macros defined
as \prm {permanent} or \prm {immutable}. However, a macro package might want
to get around this in controlled situations, which is why we have a \prm
{enforced} prefix. This prefix in interpreted differently in so called \quote
{ini} mode when macro definitions can be dumped in the format. Internally they
get an \type {always} flag as indicator that in these places an overload is
possible.

\starttyping
\permanent\def\foo{original}

\def\oof         {\def\foo{fails}}
\def\oof{\enforced\def\foo{succeeds}}
\stoptyping

Of course this only has an effect when overload protection is enabled.

\stopnewprimitive

\startoldprimitive[title={\prm {eofinput}}]

This is a variant on \prm {input} that takes a token list as first argument. That
list is expanded when the file ends. It has companion primitives \prm
{atendoffile} (single token) and \prm {atendoffiled} (multiple tokens).

\stopoldprimitive

% \startoldprimitive[title={\prm {eqno}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {errhelp}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {errmessage}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {errorcontextlines}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {errorstopmode}}]
%     TODO
% \stopoldprimitive

\startoldprimitive[title={\prm {escapechar}}]

This internal integer has the code point of the character that get prepended to a
control sequence when it is serialized (for instance in tracing or messages).

\stopoldprimitive

\startnewprimitive[title={\prm {etoks}}]

This assigns an expanded token list to a token register:

\starttyping
\def\temp{less stuff}
\etoks\scratchtoks{a bit \temp}
\stoptyping

The orginal value of the register is lost.

\stopnewprimitive

\startnewprimitive[title={\prm {etoksapp}}]

A variant of \prm {toksapp} is the following: it expands the to be appended
content.

\starttyping
\def\temp{more stuff}
\etoksapp\scratchtoks{some \temp}
\stoptyping

\stopnewprimitive

\startnewprimitive[title={\prm {etokspre}}]

A variant of \prm {tokspre} is the following: it expands the to be prepended
content.

\starttyping
\def\temp{less stuff}
\etokspre\scratchtoks{a bit \temp}
\stoptyping

\stopnewprimitive

% \startnewprimitive[title={\prm {eufactor}}]
%     TODO
% \stopnewprimitive

% \startnewprimitive[title={\prm {everybeforepar}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {everycr}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {everydisplay}}]
% \stopoldprimitive

\startoldprimitive[title={\prm {everyeof}}]

The content of this token list is injected when a file ends but it can only be
used reliably when one is really sure that no other file is loaded in the
process. So in the end it is of no real use in a more complex macro package.

\stopoldprimitive

% \startoldprimitive[title={\prm {everyhbox}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {everyjob}}]
%     TODO
% \stopoldprimitive

% \startoldprimitive[title={\prm {everymath}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {everymathatom}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {everypar}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {everytab}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {everyvbox}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {exceptionpenalty}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {exhyphenchar}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {exhyphenpenalty}}]
% \stopoldprimitive

\startnewprimitive[title={\prm {expand}}]

Beware, this is not a prefix but a directive to ignore the protected characters of
the following macro.

\startbuffer
\protected \def \testa{\the\scratchcounter}
           \edef\testb{\testa}
           \edef\testc{\expand\testa}
\stopbuffer

\typebuffer

The meaning of the three macros is:

\startlines \getbuffer \tttf
\meaningfull\testa
\meaningfull\testb
\meaningfull\testc
\stoplines

\stopnewprimitive

\startnewprimitive[title={\prm {expandactive}}]

This a bit of an outlier and mostly there for completeness.

\startbuffer
                          \meaningasis~
\edef\foo{~}              \meaningasis\foo
\edef\foo{\expandactive~} \meaningasis\foo
\stopbuffer

\typebuffer

There seems to be no difference but the real meaning of the first \type {\foo} is
\quote {active character 126} while the second \type {\foo} \quote {protected
call ~} is.

% \showluatokens\foo

\startlines
\getbuffer
\stoplines

Of course the definition of the active tilde is \CONTEXT\ specific and situation
dependent.

\stopnewprimitive

\startoldprimitive[title={\prm {expandafter}}]

This original \TEX\ primitive stores the next token, does a one level expansion
of what follows it, which actually can be an not expandable token, and
reinjects the stored token in the input. Like:

\starttyping
\expandafter\let\csname my weird macro name\endcsname{m w m n}
\stoptyping

Without \prm {expandafter} the \prm {csname} primitive would have been let to
the left brace (effectively then a begin group). Actually in this particular case
the control sequence with the weird name is injected and when it didn't yet exist
it will get the meaning \prm {relax} so we sort of have two assignments in a
row then.

\stopoldprimitive

\startnewprimitive[title={\prm {expandafterpars}}]

Here is another gobbler: the next token is reinjected after following spaces
and par tokens have been read. So:

\startbuffer
[\expandafterpars 1 2]
[\expandafterpars 3
4]
[\expandafterpars 5

6]
\stopbuffer

\typebuffer

gives us: \inlinebuffer, because empty lines are like \prm {par} and therefore
ignored.

\stopnewprimitive

\startnewprimitive[title={\prm {expandafterspaces}}]

This is a gobbler: the next token is reinjected after following spaces have been
read. Here is a simple example:

\startbuffer
[\expandafterspaces 1 2]
[\expandafterspaces 3
4]
[\expandafterspaces 5

6]
\stopbuffer

\typebuffer

We get this typeset: \inlinebuffer, because a newline normally is configured to be
a space (and leading spaces in a line are normally being ingored anyway).

\stopnewprimitive

\startnewprimitive[title={\prm {expandcstoken}}]

The rationale behind this primitive is that when we \prm {let} a single token
like a character it is hard to compare that with something similar, stored in a
macro. This primitive pushes back a single token alias created by \prm {let}
into the input.

\startbuffer
\let\tempA + \meaning\tempA

\let\tempB X \meaning\tempB \crlf
\let\tempC $ \meaning\tempC \par

\edef\temp         {\tempA} \doifelse{\temp}{+}{Y}{N} \meaning\temp \crlf
\edef\temp         {\tempB} \doifelse{\temp}{X}{Y}{N} \meaning\temp \crlf
\edef\temp         {\tempC} \doifelse{\temp}{X}{Y}{N} \meaning\temp \par

\edef\temp{\expandcstoken\tempA} \doifelse{\temp}{+}{Y}{N} \meaning\temp \crlf
\edef\temp{\expandcstoken\tempB} \doifelse{\temp}{X}{Y}{N} \meaning\temp \crlf
\edef\temp{\expandcstoken\tempC} \doifelse{\temp}{$}{Y}{N} \meaning\temp \par

\doifelse{\expandcstoken\tempA}{+}{Y}{N}
\doifelse{\expandcstoken\tempB}{X}{Y}{N}
\doifelse{\expandcstoken\tempC}{$}{Y}{N} \par
\stopbuffer

\typebuffer

The meaning of the \prm {let} macros shows that we have a shortcut to a
character with (in this case) catcode letter, other (here \quote {other
character} gets abbreviated to \quote {character}), math shift etc.

\start \tttf \getbuffer \stop

Here we use the \CONTEXT\ macro \type {\doifelse} which can be implemented in
different ways, but the only property relevant to the user is that the expanded
content of the two arguments is compared.

\stopnewprimitive

\startnewprimitive[title={\prm {expanded}}]

This primitive complements the two expansion related primitives mentioned in the
previous two sections. This time the content will be expanded and then pushed
back into the input. Protected macros will not be expanded, so you can use this
primitive to expand the arguments in a call. In \CONTEXT\ you need to use \type
{\normalexpanded} because we already had a macro with that name. We give some
examples:

\startbuffer
\def\A{!}
          \def\B#1{\string#1}                          \B{\A}
          \def\B#1{\string#1} \normalexpanded{\noexpand\B{\A}}
\protected\def\B#1{\string#1}                          \B{\A}
\stopbuffer

\typebuffer \startlines\getbuffer\stoplines

\stopnewprimitive

\startnewprimitive[title={\prm {expandedafter}}]

The following two lines are equivalent:

\startbuffer
\def\foo{123}
\expandafter[\expandafter[\expandafter\secondofthreearguments\foo]]
\expandedafter{[[\secondofthreearguments}\foo]]
\stopbuffer

\typebuffer

In \CONTEXT\ \MKIV\ the number of times that one has multiple \prm {expandafter}s
is much larger than in \CONTEXT\ \LMTX\ thanks to some of the new features in
\LUAMETATEX, and this primitive is not really used yet in the core code.

\startlines\getbuffer\stoplines

\stopnewprimitive

\startnewprimitive[title={\prm {expandedendless}}]

This one loops forever but because the loop counter is not set you need to find a
way to quit it.

\stopnewprimitive

\startnewprimitive[title={\prm {expandedloop}}]

This variant of the previously introduced \prm {localcontrolledloop} doesn't
enter a local branch but immediately does its work. This means that it can be
used inside an expansion context like \prm {edef}.

\startbuffer
\edef\whatever
  {\expandedloop 1 10 1
     {\scratchcounter=\the\currentloopiterator\relax}}

\meaningasis\whatever
\stopbuffer

\typebuffer

\start \veryraggedright \tt\tfx \getbuffer \stop \blank

\stopnewprimitive

\startnewprimitive[title={\prm {expandedrepeat}}]

This one takes one instead of three arguments which is sometimes more
convenient.

\stopnewprimitive

\startnewprimitive[title={\prm {expandparameter}}]

This primitive is a predecessor of \prm {parameterdef} so we stick to a simple
example.

\startbuffer
\def\foo#1#2%
  {\integerdef\MyIndexOne\parameterindex\plusone % 1
   \integerdef\MyIndexTwo\parameterindex\plustwo % 2
   \oof{P}\oof{Q}\oof{R}\norelax}

\def\oof#1%
  {<1:\expandparameter\MyIndexOne><1:\expandparameter\MyIndexOne>%
   #1%
   <2:\expandparameter\MyIndexTwo><2:\expandparameter\MyIndexTwo>}

\foo{A}{B}
\stopbuffer

\typebuffer

In principle the whole parameter stack can be accessed but often
one never knows if a specific macro is called nested. The original
idea behind this primitive was tracing but it can also be used to
avoid passing parameters along a chain of calls.

\getbuffer

\stopnewprimitive

\startnewprimitive[title={\prm {expandtoken}}]

This primitive creates a token with a specific combination of catcode and
character code. Because it assumes some knowledge of \TEX\ we can show it
using some \prm {expandafter} magic:

\startbuffer
\expandafter\let\expandafter\temp\expandtoken 11 `X \meaning\temp
\expandafter\let\expandafter\temp\expandtoken 12 `X \meaning\temp
\stopbuffer

\typebuffer

The meanings are:

\startlines \tttf \getbuffer \stoplines

Using other catcodes is possible but the results of injecting them into the input
directly (or here by injecting \type {\temp}) can be unexpected because of what
\TEX\ expects. You can get messages you normally won't get, for instance about
unexpected alignment interference, which is a side effect of \TEX\ using some
catcode|/|character combinations as signals and there is no reason to change
those internals. That said:

\startbuffer
\xdef\tempA{\expandtoken  9 `X} \meaning\tempA
\xdef\tempB{\expandtoken 10 `X} \meaning\tempB
\xdef\tempC{\expandtoken 11 `X} \meaning\tempC
\xdef\tempD{\expandtoken 12 `X} \meaning\tempD
\stopbuffer

\typebuffer

are all valid and from the meaning you cannot really deduce what's in there:

\startlines \tttf \getbuffer \stoplines % grouped therefore xdef

But you can be assured that:

\startbuffer
[AB: \ifx\tempA\tempB Y\else N\fi]
[AC: \ifx\tempA\tempC Y\else N\fi]
[AD: \ifx\tempA\tempD Y\else N\fi]
[BC: \ifx\tempB\tempC Y\else N\fi]
[BD: \ifx\tempB\tempD Y\else N\fi]
[CD: \ifx\tempC\tempD Y\else N\fi]
\stopbuffer

\typebuffer

makes clear that they're different: \inlinebuffer, and in case you wonder, the
characters with catcode 10 are spaces, while those with code 9 are ignored.

\stopnewprimitive

\startnewprimitive[title={\prm {expandtoks}}]

This is a more efficient equivalent of \prm {the} applied to a token register,
so:

\startbuffer
\scratchtoks{just some tokens}
\edef\TestA{[\the       \scratchtoks]}
\edef\TestB{[\expandtoks\scratchtoks]}
[\the       \scratchtoks] [\TestA] \meaning\TestA
[\expandtoks\scratchtoks] [\TestB] \meaning\TestB
\stopbuffer

\typebuffer

does the expected:

\startlines
\getbuffer
\stoplines

The \prm {expandtoken} primitive avoid a copy into the input when there is no
need for it.

\stopnewprimitive

% \startnewprimitive[title={\prm {explicitdiscretionary}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {explicithyphenpenalty}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {fam}}]
% \stopoldprimitive

\startoldprimitive[title={\prm {fi}}]

This traditional primitive is part of the condition testing mechanism and ends a
test. So, we have:

\starttyping
\ifsomething ... \else ... \fi
\ifsomething ... \or ... \or ... \else ... \fi
\ifsomething ... \orelse \ifsometing  ... \else ... \fi
\ifsomething ... \or ... \orelse \ifsometing  ... \else ... \fi
\stoptyping

The \prm {orelse} is new in \LUAMETATEX\ and a continuation like we find in
other programming languages (see later section).

\stopoldprimitive

% \startoldprimitive[title={\prm {finalhyphendemerits}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {firstmark}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {firstmarks}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {firstvalidlanguage}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {float}}]
%     TODO
% \stopnewprimitive

% \startnewprimitive[title={\prm {floatdef}}]
%     TODO
% \stopnewprimitive

% \startnewprimitive[title={\prm {floatexpr}}]
%     TODO
% \stopnewprimitive

% \startoldprimitive[title={\prm {floatingpenalty}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {flushmarks}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {font}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {fontcharba}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {fontchardp}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {fontcharht}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {fontcharic}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {fontcharta}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {fontcharwd}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {fontdimen}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {fontid}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {fontmathcontrol}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {fontname}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {fontspecdef}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {fontspecid}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {fontspecifiedname}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {fontspecifiedsize}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {fontspecscale}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {fontspecxscale}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {fontspecyscale}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {fonttextcontrol}}]
% \stopnewprimitive

\startnewprimitive[title={\prm {formatname}}]

It is in the name: {\tttf \filenameonly {\formatname}}, but we cheat here by only
showing the filename and not the full path, which in a \CONTEXT\ setup can span
more than a line in this paragraph.

\stopnewprimitive

\startnewprimitive[title={\prm {frozen}}]

You can define a macro as being frozen:

\starttyping
\frozen\def\MyMacro{...}
\stoptyping

When you redefine this macro you get an error:

\starttyping
! You can't redefine a frozen macro.
\stoptyping

This is a prefix like \prm {global} and it can be combined with other prefixes.
\footnote {The \prm {outer} and \prm {long} prefixes are no|-|ops in
\LUAMETATEX\ and \LUATEX\ can be configured to ignore them.}

\stopnewprimitive

\startnewprimitive[title={\prm {futurecsname}}]

In order to make the repertoire of \type {def}, \type {let} and \type {futurelet}
primitives complete we also have:

\starttyping
\futurecsname MyMacro:1\endcsname\MyAction
\stoptyping

\stopnewprimitive

\startnewprimitive[title={\prm {futuredef}}]

We elaborate on the example of using \prm {futurelet} in the previous section.
Compare that one with the next:

\startbuffer
\def\MySpecialToken{[}
\def\DoWhatever{\ifx\NextToken\MySpecialToken YES\else NOP\fi : }
\futurelet\NextToken\DoWhatever [A]\crlf
\futurelet\NextToken\DoWhatever (A)\par
\stopbuffer

\typebuffer

This time we get:

{\getbuffer}

It is for that reason that we now also have \prm {futuredef}:

\startbuffer
\def\MySpecialToken{[}
\def\DoWhatever{\ifx\NextToken\MySpecialToken YES\else NOP\fi : }
\futuredef\NextToken\DoWhatever [A]\crlf
\futuredef\NextToken\DoWhatever (A)\par
\stopbuffer

\typebuffer

So we're back to what we want:

{\getbuffer}

\stopnewprimitive

\startnewprimitive[title={\prm {futureexpand}}]

This primitive can be used as an alternative to a \prm {futurelet} approach,
which is where the name comes from. \footnote {In the engine primitives
that have similar behavior are grouped in commands that are then dealt with
together, code wise.}

\startbuffer
\def\variantone<#1>{(#1)}
\def\varianttwo#1{[#1]}
\futureexpand<\variantone\varianttwo<one>
\futureexpand<\variantone\varianttwo{two}
\stopbuffer

\typebuffer

So, the next token determines which of the two variants is taken:

{\getbuffer}

Because we look ahead there is some magic involved: spaces are ignored but when
we have no match they are pushed back into the input. The next variant
demonstrates this:

\startbuffer
\def\variantone<#1>{(#1)}
\def\varianttwo{}
\def\temp{\futureexpand<\variantone\varianttwo}
[\temp <one>]
[\temp {two}]
[\expandafter\temp\space <one>]
[\expandafter\temp\space {two}]
\stopbuffer

\typebuffer

This gives us:

{\getbuffer}

\stopnewprimitive

\startnewprimitive[title={\prm {futureexpandis}}]

We assume that the previous section is read. This variant will not push back
spaces, which permits a consistent approach i.e.\ the user can assume that macro
always gobbles the spaces.

\startbuffer
\def\variantone<#1>{(#1)}
\def\varianttwo{}
\def\temp{\futureexpandis<\variantone\varianttwo}
[\temp <one>]
[\temp {two}]
[\expandafter\temp\space <one>]
[\expandafter\temp\space {two}]
\stopbuffer

\typebuffer

So, here no spaces are pushed back. This \type {is} in the name of this primitive
means \quote {ignore spaces}, but having that added to the name would have made
the primitive even more verbose (after all, we also don't have \type
{\expandeddef} but \prm {edef} and no \type {\globalexpandeddef} but \prm
{xdef}.

{\getbuffer}

\stopnewprimitive

\startnewprimitive[title={\prm {futureexpandisap}}]

This primitive is like the one in the previous section but also ignores par
tokens, so \type {isap} means \quote {ignore spaces and paragraphs}.

\stopnewprimitive

\startoldprimitive[title={\prm {futurelet}}]

The original \TEX\ primitive \prm {futurelet} can be used to create an alias to a next token,
push it back into the input and then expand a given token.

\startbuffer
\let\MySpecialTokenL[
\let\MySpecialTokenR] % nicer for checker
\def\DoWhatever{\ifx\NextToken\MySpecialTokenL YES\else NOP\fi : }
\futurelet\NextToken\DoWhatever [A]\crlf
\futurelet\NextToken\DoWhatever (A)\par
\stopbuffer

\typebuffer

This is typically the kind of primitive that most users will never use because it
expects a sane follow up handler (here \type {\DoWhatever}) and therefore is
related to user interfacing.

{\getbuffer}

\stopoldprimitive

\startoldprimitive[title={\prm {gdef}}]

The is the global companion of \prm {def}.

\stopoldprimitive

\startnewprimitive[title={\prm {gdefcsname}}]

As with standard \TEX\ we also define global ones:

\starttyping
\expandafter\gdef\csname MyMacro:1\endcsname{...}
             \gdefcsname MyMacro:1\endcsname{...}
\stoptyping

\stopnewprimitive

% \startnewprimitive[title={\prm {gleaders}}]
% \stopnewprimitive

\startnewprimitive[title={\prm {glet}}]

This is the global companion of \prm {let}. The fact that it is not an original
primitive is probably due to the expectation for it not it not being used (as)
often (as in \CONTEXT).

\stopnewprimitive

\startnewprimitive[title={\prm {gletcsname}}]

Naturally \LUAMETATEX\ also provides a global variant:

\starttyping
\expandafter\global\expandafter\let\csname MyMacro:1\endcsname\relax
\expandafter                  \glet\csname MyMacro:1\endcsname\relax
                               \gletcsname MyMacro:1\endcsname\relax
\stoptyping

So, here we save even more.

\stopnewprimitive

\startnewprimitive[title={\prm {glettonothing}}]

This is the global companion of \prm {lettonothing}.

\stopnewprimitive

\startoldprimitive[title={\prm {global}}]

This is one of the original prefixes that can be used when we define a macro of
change some register.

\starttyping
\bgroup
       \def\MyMacroA{a}
\global\def\MyMacroB{a}
      \gdef\MyMacroC{a}
\egroup
\stoptyping

The macro defined in the first line is forgotten when the groups is left. The
second and third definition are both global and these definitions are retained.

\stopoldprimitive

\startoldprimitive[title={\prm {globaldefs}}]

When set to a positive value, this internal integer will force all definitions to
be global, and in a complex macro package that is not something a user will do
unless it is very controlled.

\stopoldprimitive

% \startoldprimitive[title={\prm {glueexpr}}]
%     TODO
% \stopoldprimitive

\startoldprimitive[title={\prm {glueshrink}}]

This returns the shrink component of a glue quantity. The result is a dimension
so you need to apply \prm {the} when applicable.

\stopoldprimitive

\startoldprimitive[title={\prm {glueshrinkorder}}]

This returns the shrink order of a glue quantity. The result is a integer so you
need to apply \prm {the} when applicable.

\stopoldprimitive

\startnewprimitive[title={\prm {gluespecdef}}]

A variant of \prm {integerdef} and \prm {dimensiondef} is:

\starttyping
\gluespecdef\MyGlue = 3pt plus 2pt minus 1pt
\stoptyping

The properties are comparable to the ones described in the previous sections.

\stopnewprimitive

\startoldprimitive[title={\prm {gluestretch}}]

This returns the stretch component of a glue quantity. The result is a dimension
so you need to apply \prm {the} when applicable.

\stopoldprimitive

\startoldprimitive[title={\prm {gluestretchorder}}]

This returns the stretch order of a glue quantity. The result is a integer so you
need to apply \prm {the} when applicable.

\stopoldprimitive

% \startoldprimitive[title={\prm {gluetomu}}]
%     TODO
% \stopoldprimitive

% \startnewprimitive[title={\prm {glyph}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {glyphdatafield}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {glyphoptions}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {glyphscale}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {glyphscriptfield}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {glyphscriptscale}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {glyphscriptscriptscale}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {glyphstatefield}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {glyphtextscale}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {glyphxoffset}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {glyphxscale}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {glyphxscaled}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {glyphyoffset}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {glyphyscale}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {glyphyscaled}}]
% \stopnewprimitive

\startnewprimitive[title={\prm {gtoksapp}}]

This is the global variant of \prm {toksapp}.

\stopnewprimitive

\startnewprimitive[title={\prm {gtokspre}}]

This is the global variant of \prm {tokspre}.

\stopnewprimitive

% \startoldprimitive[title={\prm {halign}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {hangafter}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {hangindent}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {hbadness}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {hbox}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {hccode}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {hfil}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {hfill}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {hfilneg}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {hfuzz}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {hjcode}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {hkern}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {hmcode}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {holdinginserts}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {holdingmigrations}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {hpack}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {hpenalty}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {hrule}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {hsize}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {hskip}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {hss}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {ht}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {hyphenation}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {hyphenationmin}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {hyphenationmode}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {hyphenchar}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {hyphenpenalty}}]
% \stopoldprimitive

\startoldprimitive[title={\prm {if}}]

This traditional \TEX\ conditional checks if two character codes are the same. In
order to understand unexpanded results it is good to know that internally \TEX\
groups primitives in a way that serves the implementation. Each primitive has a
command code and a character code, but only for real characters the name
character code makes sense. This condition only really tests for character codes
when we have a character, in all other cases, the result is true.

\startbuffer
\def\A{A}\def\B{B} \chardef\C=`C \chardef\D=`D \def\AA{AA}

[\if AA   YES \else NOP \fi] [\if AB   YES \else NOP \fi]
[\if \A\B YES \else NOP \fi] [\if \A\A YES \else NOP \fi]
[\if \C\D YES \else NOP \fi] [\if \C\C YES \else NOP \fi]
[\if \count\dimen YES \else NOP \fi] [\if \AA\A YES \else NOP \fi]

\stopbuffer

\typebuffer

The last example demonstrates that the tokens get expanded, which is why
we get the extra \type {A}:

{\getbuffer}

\stopoldprimitive

\startnewprimitive[title={\prm {ifabsdim}}]

This test will negate negative dimensions before comparison, as in:

\startbuffer
\def\TestA#1{\ifdim   #1<2pt too small\orelse\ifdim   #1>4pt too large\else okay\fi}
\def\TestB#1{\ifabsdim#1<2pt too small\orelse\ifabsdim#1>4pt too large\else okay\fi}

\TestA {1pt}\quad\TestA {3pt}\quad\TestA {5pt}\crlf
\TestB {1pt}\quad\TestB {3pt}\quad\TestB {5pt}\crlf
\TestB{-1pt}\quad\TestB{-3pt}\quad\TestB{-5pt}\par
\stopbuffer

\typebuffer

So we get this:

{\getbuffer}

\stopnewprimitive

\startnewprimitive[title={\prm {ifabsfloat}}]

This test will negate negative floats before comparison, as in:

\startbuffer
\def\TestA#1{\iffloat   #1<2.46 small\orelse\iffloat   #1>4.68 large\else medium\fi}
\def\TestB#1{\ifabsfloat#1<2.46 small\orelse\ifabsfloat#1>4.68 large\else medium\fi}

\TestA {1.23}\quad\TestA {3.45}\quad\TestA {5.67}\crlf
\TestB {1.23}\quad\TestB {3.45}\quad\TestB {5.67}\crlf
\TestB{-1.23}\quad\TestB{-3.45}\quad\TestB{-5.67}\par
\stopbuffer

\typebuffer

So we get this:

{\getbuffer}

\stopnewprimitive

\startnewprimitive[title={\prm {ifabsnum}}]

This test will negate negative numbers before comparison, as in:

\startbuffer
\def\TestA#1{\ifnum   #1<100 too small\orelse\ifnum   #1>200 too large\else okay\fi}
\def\TestB#1{\ifabsnum#1<100 too small\orelse\ifabsnum#1>200 too large\else okay\fi}

\TestA {10}\quad\TestA {150}\quad\TestA {210}\crlf
\TestB {10}\quad\TestB {150}\quad\TestB {210}\crlf
\TestB{-10}\quad\TestB{-150}\quad\TestB{-210}\par
\stopbuffer

\typebuffer

Here we get the same result each time:

{\getbuffer}

\stopnewprimitive

\startnewprimitive[title={\prm {ifarguments}}]

This is a variant of \prm {ifcase} were the selector is the number of arguments
picked up. For example:

\startbuffer
\def\MyMacro#1#2#3{\ifarguments\0\or1\or2\or3\else ?\fi} \MyMacro{A}{B}{C}
\def\MyMacro#1#0#3{\ifarguments\0\or1\or2\or3\else ?\fi} \MyMacro{A}{B}{C}
\def\MyMacro#1#-#2{\ifarguments\0\or1\or2\or3\else ?\fi} \MyMacro{A}{B}{C}\par
\stopbuffer

\typebuffer

Watch the non counted, ignored, argument in the last case. Normally this test will
be used in combination with \prm {ignorearguments}.

{\getbuffer}

\stopnewprimitive

\startnewprimitive[title={\prm {ifboolean}}]

This tests a number (register or equivalent) and any nonzero value represents
\type {true}, which is nicer than using an \type {\unless \ifcase}.

\stopnewprimitive

\startoldprimitive[title={\prm {ifcase}}]

This numeric \TEX\ conditional takes a counter (literal, register, shortcut to a
character, internal quantity) and goes to the branch that matches.

\startbuffer
\ifcase 3 zero\or one\or two\or three\or four\else five or more\fi
\stopbuffer

\typebuffer

Indeed: \inlinebuffer\ equals three. In later sections we will see some
\LUAMETATEX\ primitives that behave like an \prm {ifcase}.

\stopoldprimitive

\startoldprimitive[title={\prm {ifcat}}]

Another traditional \TEX\ primitive: what happens with what gets read in depends
on the catcode of a character, think of characters marked to start math mode, or
alphabetic characters (letters) versus other characters (like punctuation).

\startbuffer
\def\A{A}\def\B{,} \chardef\C=`C \chardef\D=`, \def\AA{AA}

[\ifcat $!   YES \else NOP \fi] [\ifcat ()   YES \else NOP \fi]
[\ifcat AA   YES \else NOP \fi] [\ifcat AB   YES \else NOP \fi]
[\ifcat \A\B YES \else NOP \fi] [\ifcat \A\A YES \else NOP \fi]
[\ifcat \C\D YES \else NOP \fi] [\ifcat \C\C YES \else NOP \fi]
[\ifcat \count\dimen YES \else NOP \fi] [\ifcat \AA\A YES \else NOP \fi]
\stopbuffer

\typebuffer

Close reading is needed here:

{\getbuffer}

This traditional \TEX\ condition as a well as the one in the previous section are
hardly used in \CONTEXT, if only because they expand what follows and we seldom
need to compare characters.

\stopoldprimitive

\startnewprimitive[title={\prm {ifchkdim}}]

A variant on the checker in the previous section is a dimension checker:

\startbuffer
\ifchkdim oeps        \or okay\else error\fi\quad
\ifchkdim 12          \or okay\else error\fi\quad
\ifchkdim 12pt        \or okay\else error\fi\quad
\ifchkdim 12pt or more\or okay\else error\fi
\stopbuffer

\typebuffer

We get:

{\getbuffer}

\stopnewprimitive

\startnewprimitive[title={\prm {ifchkdimension}}]

COntrary to \prm {ifchkdim} this test doesn't accept trailing crap:

\startbuffer
\ifchkdimension oeps        \or okay\else error\fi\quad
\ifchkdimension 12          \or okay\else error\fi\quad
\ifchkdimension 12pt        \or okay\else error\fi\quad
\ifchkdimension 12pt or more\or okay\else error\fi
\stopbuffer

\typebuffer

reports:

{\getbuffer}

\stopnewprimitive

\startnewprimitive[title={\prm {ifchknum}}]

In \CONTEXT\ there are quite some cases where a variable can have a number or a
keyword indicating a symbolic name of a number or maybe even some special
treatment. Checking if a valid number is given is possible to some extend, but a
native checker makes much sense too. So here is one:

\startbuffer
\ifchknum oeps        \or okay\else error\fi\quad
\ifchknum 12          \or okay\else error\fi\quad
\ifchknum 12pt        \or okay\else error\fi\quad
\ifchknum 12pt or more\or okay\else error\fi
\stopbuffer

\typebuffer

The result is as expected:

{\getbuffer}

\stopnewprimitive

\startnewprimitive[title={\prm {ifchknumber}}]

This check is more restrictive than \prm {ifchknum} discussed in the previous
section:

\startbuffer
\ifchknumber oeps        \or okay\else error\fi\quad
\ifchknumber 12          \or okay\else error\fi\quad
\ifchknumber 12pt        \or okay\else error\fi\quad
\ifchknumber 12pt or more\or okay\else error\fi
\stopbuffer

\typebuffer

Here we get:

{\getbuffer}

\stopnewprimitive

\startnewprimitive[title={\prm {ifcmpdim}}]

This conditional compares two dimensions and the resulting \prm {ifcase}
reflects their relation:

\startbuffer
[1pt 2pt : \ifcmpdim 1pt 2pt less\or equal\or more\fi]\quad
[1pt 1pt : \ifcmpdim 1pt 1pt less\or equal\or more\fi]\quad
[2pt 1pt : \ifcmpdim 2pt 1pt less\or equal\or more\fi]
\stopbuffer

\typebuffer

This gives:

{\getbuffer}

\stopnewprimitive

\startnewprimitive[title={\prm {ifcmpnum}}]

This conditional compares two numbers and the resulting \prm {ifcase} reflects
their relation:

\startbuffer
[1 2 : \ifcmpnum 1 2 less\or equal\or more\fi]\quad
[1 1 : \ifcmpnum 1 1 less\or equal\or more\fi]\quad
[2 1 : \ifcmpnum 2 1 less\or equal\or more\fi]
\stopbuffer

\typebuffer

This gives:

{\getbuffer}

\stopnewprimitive

\startnewprimitive[title={\prm {ifcondition}}]

The conditionals in \TEX\ are hard coded as primitives and although it might
look like \type {\newif} creates one, it actually just defined three macros.

\startbuffer
\newif\ifMyTest
\meaning\MyTesttrue  \crlf
\meaning\MyTestfalse \crlf
\meaning\ifMyTest    \crlf \MyTesttrue
\meaning\ifMyTest    \par
\stopbuffer

\typebuffer {\tttf \getbuffer}

This means that when you say:

\starttyping
\ifMytest ... \else ... \fi
\stoptyping

You actually have one of:

\starttyping
\iftrue  ... \else ... \fi
\iffalse ... \else ... \fi
\stoptyping

and because these are proper conditions nesting them like:

\starttyping
\ifnum\scratchcounter > 0 \ifMyTest A\else B\fi \fi
\stoptyping

will work out well too. This is not true for macros, so for instance:

\starttyping
\scratchcounter = 1
\unexpanded\def\ifMyTest{\iftrue}
\ifnum\scratchcounter > 0 \ifMyTest A\else B\fi \fi
\stoptyping

will make a run fail with an error (or simply loop forever, depending on your
code). This is where \prm {ifcondition} enters the picture:

\starttyping
\def\MyTest{\iftrue} \scratchcounter0
\ifnum\scratchcounter > 0
    \ifcondition\MyTest A\else B\fi
\else
    x
\fi
\stoptyping

This primitive is seen as a proper condition when \TEX\ is in \quotation {fast
skipping unused branches} mode but when it is expanding a branch, it checks if
the next expanded token is a proper tests and if so, it deals with that test,
otherwise it fails. The main condition here is that the \type {\MyTest} macro
expands to a proper true or false test, so, a definition like:

\starttyping
\def\MyTest{\ifnum\scratchcounter<10 }
\stoptyping

is also okay. Now, is that neat or not?

\stopnewprimitive

\startoldprimitive[title={\prm {ifcsname}}]

This is an \ETEX\ conditional that complements the one on the previous section:

\starttyping
\expandafter\ifx\csname MyMacro\endcsname\relax ... \else ... \fi
            \ifcsname   MyMacro\endcsname       ... \else ... \fi
\stoptyping

Here the first one has the side effect of defining the macro and defaulting it to
\prm {relax}, while the second one doesn't do that. Juts think of checking a
few million different names: the first one will deplete the hash table and
probably string space too.

In \LUAMETATEX\ the construction stops when there is no letter or other character
seen (\TEX\ expands on the go so expandable macros are dealt with). Instead of an
error message, the match is simply false and all tokens till the \prm
{endcsname} are gobbled.

\stopoldprimitive

\startnewprimitive[title={\prm {ifcstok}}]

A variant on the primitive mentioned in the previous section is one that
operates on lists and macros:

\startbuffer[a]
\def\a{a} \def\b{b} \def\c{a}
\stopbuffer

\typebuffer[a]

\startbuffer[b]
\ifcstok\a\b   Y\else N\fi\space
\ifcstok\a\c   Y\else N\fi\space
\ifcstok{\a}\c Y\else N\fi\space
\ifcstok{a}\c  Y\else N\fi
\stopbuffer

This:

\typebuffer[b]

{\getbuffer[a]will give us: \inlinebuffer[b].}

\stopnewprimitive

\startoldprimitive[title={\prm {ifdefined}}]

In traditional \TEX\ checking for a macro to exist was a bit tricky and therefore
\ETEX\ introduced a convenient conditional. We can do this:

\starttyping
\ifx\MyMacro\undefined ... \else ... \fi
\stoptyping

but that assumes that \type {\undefined} is indeed undefined. Another test often
seen was this:

\starttyping
\expandafter\ifx\csname MyMacro\endcsname\relax ... \else ... \fi
\stoptyping

Instead of comparing with \type {\undefined} we need to check with \prm {relax}
because the control sequence is defined when not yet present and defaults to
\prm {relax}. This is not pretty.

\stopoldprimitive

\startoldprimitive[title={\prm {ifdim}}]

Dimensions can be compared with this traditional \TEX\ primitive.

\startbuffer
\scratchdimen=1pt \scratchcounter=65536

\ifdim\scratchdimen=\scratchcounter sp YES \else NOP\fi
\ifdim\scratchdimen=1               pt YES \else NOP\fi
\stopbuffer

\typebuffer

The units are mandate:

{\getbuffer}

\stopoldprimitive

\startnewprimitive[title={\prm {ifdimexpression}}]

The companion of the previous primitive is:

\startbuffer
\ifdimexpression 10pt > 10bp \relax
    do-something
\fi
\stopbuffer

This matches when the result is non zero, and you can mix calculations and tests
as with normal expressions. Contrary to the number variant units can be used and
precision kicks in.

\stopnewprimitive

\startnewprimitive[title={\prm {ifdimval}}]

This conditional is a variant on \prm {ifchkdim} and provides some more
detailed information about the value:

\startbuffer
[-12pt : \ifdimval-12pt\or negative\or zero\or positive\else error\fi]\quad
[0pt   : \ifdimval  0pt\or negative\or zero\or positive\else error\fi]\quad
[12pt  : \ifdimval 12pt\or negative\or zero\or positive\else error\fi]\quad
[oeps  : \ifdimval oeps\or negative\or zero\or positive\else error\fi]
\stopbuffer

\typebuffer

This gives:

{\getbuffer}

\stopnewprimitive

\startnewprimitive[title={\prm {ifempty}}]

This conditional checks if a control sequence is empty:

\starttyping
is \ifempty\MyMacro \else not \fi empty
\stoptyping

It is basically a shortcut of:

\starttyping
is \ifx\MyMacro\empty \else not \fi empty
\stoptyping

with:

\starttyping
\def\empty{}
\stoptyping

Of course this is not empty at all:

\starttyping
\def\notempty#1{}
\stoptyping

\stopnewprimitive

\startoldprimitive[title={\prm {iffalse}}]

Here we have a traditional \TEX\ conditional that is always false (therefore the
same is true for any macro that is \prm {let} to this primitive).

\stopoldprimitive

\startnewprimitive[title={\prm {ifflags}}]

This test primitive relates to the various flags that one can set on a control
sequence in the perspective of overload protection and classification.

\startbuffer
\protected\untraced\tolerant\def\foo[#1]{...#1...}
\permanent\constant         \def\oof{okay}
\stopbuffer

\typebuffer

\start \getbuffer
\starttabulate[|l|c|c|l|c|c|]
\FL
\NC flag          \NC \type  {\foo}                          \NC \type  {\oof}
\NC flag          \NC \type  {\foo}                          \NC \type  {\oof}                          \NC \NR
\ML
\NC frozen        \NC \ifflags\foo\frozen        Y\else N\fi \NC \ifflags\oof\frozen        Y\else N\fi
\NC permanent     \NC \ifflags\foo\permanent     Y\else N\fi \NC \ifflags\oof\permanent     Y\else N\fi \NC \NR
\NC immutable     \NC \ifflags\foo\immutable     Y\else N\fi \NC \ifflags\oof\immutable     Y\else N\fi
\NC mutable       \NC \ifflags\foo\mutable       Y\else N\fi \NC \ifflags\oof\mutable       Y\else N\fi \NC \NR
\NC noaligned     \NC \ifflags\foo\noaligned     Y\else N\fi \NC \ifflags\oof\noaligned     Y\else N\fi
\NC instance      \NC \ifflags\foo\instance      Y\else N\fi \NC \ifflags\oof\instance      Y\else N\fi \NC \NR
\NC untraced      \NC \ifflags\foo\untraced      Y\else N\fi \NC \ifflags\oof\untraced      Y\else N\fi
\NC global        \NC \ifflags\foo\global        Y\else N\fi \NC \ifflags\oof\global        Y\else N\fi \NC \NR
\NC tolerant      \NC \ifflags\foo\tolerant      Y\else N\fi \NC \ifflags\oof\tolerant      Y\else N\fi
\NC constant      \NC \ifflags\foo\constant      Y\else N\fi \NC \ifflags\oof\constant      Y\else N\fi \NC \NR
\NC protected     \NC \ifflags\foo\protected     Y\else N\fi \NC \ifflags\oof\protected     Y\else N\fi
\NC semiprotected \NC \ifflags\foo\semiprotected Y\else N\fi \NC \ifflags\oof\semiprotected Y\else N\fi \NC \NR
\LL
\stoptabulate
\stop

Instead of checking against a prefix you can test against a bitset made from:

\startluacode
context.starttabulate { "|r|l|r|l|r|l|r|l|" }
local n = 4
for k, v in table.sortedhash(tex.flagcodes) do
    if tonumber(k) then
        n = n - 1
        context.NC() context("0x%X",k)
        context.NC() context(v)
        if n == 0 then
            context.NC()
            context.NR()
            n = 4
        end
    end
end
context.stoptabulate()
\stopluacode

\stopnewprimitive

% \startnewprimitive[title={\prm {iffloat}}]
%     TODO
% \stopnewprimitive

\startoldprimitive[title={\prm {iffontchar}}]

This is an \ETEX\ conditional. It takes a font identifier and a character number.
In modern fonts simply checking could not be enough because complex font features
can swap in other ones and their index can be anything. Also, a font mechanism
can provide fallback fonts and characters, so don't rely on this one too much. It
just reports true when the font passed to the frontend has a slot filled.

\stopoldprimitive

\startnewprimitive[title={\prm {ifhaschar}}]

This one is a simplified variant of the above:

\startbuffer
\ifhaschar !{this ! works} yes \else no \fi
\stopbuffer

\typebuffer

and indeed we get: \inlinebuffer ! Of course the spaces in this this example
code are normally not present in such a test.

\stopnewprimitive

\startnewprimitive[title={\prm {ifhastok}}]

This conditional looks for occurrences in token lists where each argument has to
be a proper list.

\startbuffer
\def\scratchtoks{x}

\ifhastoks{yz}         {xyz} Y\else N\fi\quad
\ifhastoks\scratchtoks {xyz} Y\else N\fi
\stopbuffer

\typebuffer

We get:

{\getbuffer}

\stopnewprimitive

\startnewprimitive[title={\prm {ifhastoks}}]

This test compares two token lists. When a macro is passed it's meaning
gets used.

\startbuffer
\def\x  {x}
\def\xyz{xyz}

(\ifhastoks  {x}  {xyz}Y\else N\fi)\quad
(\ifhastoks {\x}  {xyz}Y\else N\fi)\quad
(\ifhastoks  \x   {xyz}Y\else N\fi)\quad
(\ifhastoks  {y}  {xyz}Y\else N\fi)\quad
(\ifhastoks {yz}  {xyz}Y\else N\fi)\quad
(\ifhastoks {yz} {\xyz}Y\else N\fi)
\stopbuffer

\typebuffer {\getbuffer}

\stopnewprimitive

\startnewprimitive[title={\prm {ifhasxtoks}}]

This primitive is like the one in the previous section but this time the
given lists are expanded.

\startbuffer
\def\x  {x}
\def\xyz{\x yz}

(\ifhasxtoks  {x}  {xyz}Y\else N\fi)\quad
(\ifhasxtoks {\x}  {xyz}Y\else N\fi)\quad
(\ifhastoks   \x   {xyz}Y\else N\fi)\quad
(\ifhasxtoks  {y}  {xyz}Y\else N\fi)\quad
(\ifhasxtoks {yz}  {xyz}Y\else N\fi)\quad
(\ifhasxtoks {yz} {\xyz}Y\else N\fi)
\stopbuffer

\typebuffer {\getbuffer}

This primitive has some special properties.

\startbuffer
\edef\+{\expandtoken 9 `+}

\ifhasxtoks {xy}   {xyz}Y\else N\fi\quad
\ifhasxtoks {x\+y} {xyz}Y\else N\fi
\stopbuffer

\typebuffer

Here the first argument has a token that has category code \quote {ignore} which
means that such a character will be skipped when seen. So the result is:

{\getbuffer}

This permits checks like these:

\startbuffer
\edef\,{\expandtoken 9 `,}

\ifhasxtoks{\,x\,} {,x,y,z,}Y\else N\fi\quad
\ifhasxtoks{\,y\,} {,x,y,z,}Y\else N\fi\quad
\ifhasxtoks{\,z\,} {,x,y,z,}Y\else N\fi\quad
\ifhasxtoks{\,x\,}  {,xy,z,}Y\else N\fi
\stopbuffer

\typebuffer

I admit that it needs a bit of a twisted mind to come up with this, but it works
ok:

{\getbuffer}

\stopnewprimitive

\startoldprimitive[title={\prm {ifhbox}}]

This traditional conditional checks if a given box register or internal box
variable represents a horizontal box,

\stopoldprimitive

\startoldprimitive[title={\prm {ifhmode}}]

This traditional conditional checks we are in (restricted) horizontal mode.

\stopoldprimitive

\startnewprimitive[title={\prm {ifincsname}}]

This conditional is sort of obsolete and can be used to check if we're inside a
\prm {csname} or \prm {ifcsname} construction. It's not used in \CONTEXT.

\stopnewprimitive

\startoldprimitive[title={\prm {ifinner}}]

This traditional one can be confusing. It is true when we are in restricted
horizontal mode (a box), internal vertical mode (a box), or inline math mode.

\startbuffer
test \ifhmode \ifinner INNER\fi HMODE\fi\crlf
\hbox{test \ifhmode \ifinner INNER \fi HMODE\fi} \par

\ifvmode \ifinner INNER\fi VMODE \fi\crlf
\vbox{\ifvmode \ifinner INNER \fi VMODE\fi} \crlf
\vbox{\ifinner INNER \ifvmode VMODE \fi \fi} \par
\stopbuffer

\typebuffer

Watch the last line: because we typeset \type {INNER} we enter horizontal mode:

{\getbuffer}

\stopoldprimitive

% \startnewprimitive[title={\prm {ifinsert}}]
%     TODO
% \stopnewprimitive

% \startnewprimitive[title={\prm {ifintervaldim}}]
%     TODO
% \stopnewprimitive

% \startnewprimitive[title={\prm {ifintervalfloat}}]
%     TODO
% \stopnewprimitive

% \startnewprimitive[title={\prm {ifintervalnum}}]
%     TODO
% \stopnewprimitive

\startnewprimitive[title={\prm {ifmathparameter}}]

This is an \prm {ifcase} where the value depends on if the given math parameter
is zero, (\type {0}), set (\type {1}), or unset (\type {2}).

\starttyping
\ifmathparameter\Umathpunctclosespacing\displaystyle
    zero    \or
    nonzero \or
    unset   \fi
\stoptyping

\stopnewprimitive

\startnewprimitive[title={\prm {ifmathstyle}}]

This is a variant of \prm {ifcase} were the number is one of the seven possible
styles: display, text, cramped text, script, cramped script, script script,
cramped script script.

\starttyping
\ifmathstyle
  display
\or
  text
\or
  cramped text
\else
  normally smaller than text
\fi
\stoptyping

\stopnewprimitive

\startoldprimitive[title={\prm {ifmmode}}]

This traditional conditional checks we are in (inline or display) math mode mode.

\stopoldprimitive

\startoldprimitive[title={\prm {ifnum}}]

This is a frequently used conditional: it compares two numbers where a number is
anything that can be seen as such.

\startbuffer
\scratchcounter=65 \chardef\A=65

\ifnum65=`A              YES \else NOP\fi
\ifnum\scratchcounter=65 YES \else NOP\fi
\ifnum\scratchcounter=\A YES \else NOP\fi
\stopbuffer

\typebuffer

Unless a number is an unexpandable token it ends with a space or \prm {relax},
so when you end up in the true branch, you'd better check if \TEX\ could
determine where the number ends.

{\getbuffer}

% When comparing integers, definitions (for instance characters) that can be seen
% as such, or any converter that produces a number (like the \type {`} or \prm
% {number} the usual \type {=}, \type {<} or \type {>} can be used. However, in
% \LUAMETATEX\ you can negate such a comparison by \type {!}: \type {!=}, \type
% {!<} or \type {!>}. Successive \type {!} toggle the negation state.

On top of these \ASCII\ combinations, the engine also accepts some \UNICODE\
characters. This brings the full repertoire to:

\starttabulate[|l|cT|cT|l|]
\FL
\BC character      \BC               \BC    \BC operation         \NC \NR
\ML
\NC \type {0x003C} \NC $\Uchar"003C$ \NC    \NC less              \NC \NR
\NC \type {0x003D} \NC $\Uchar"003D$ \NC    \NC equal             \NC \NR
\NC \type {0x003E} \NC $\Uchar"003E$ \NC    \NC more              \NC \NR
\NC \type {0x2208} \NC $\Uchar"2208$ \NC    \NC element of        \NC \NR
\NC \type {0x2209} \NC $\Uchar"2209$ \NC    \NC not element of    \NC \NR
\NC \type {0x2260} \NC $\Uchar"2260$ \NC != \NC not equal         \NC \NR
\NC \type {0x2264} \NC $\Uchar"2264$ \NC !> \NC less equal        \NC \NR
\NC \type {0x2265} \NC $\Uchar"2265$ \NC !< \NC greater equal     \NC \NR
\NC \type {0x2270} \NC $\Uchar"2270$ \NC    \NC not less equal    \NC \NR
\NC \type {0x2271} \NC $\Uchar"2271$ \NC    \NC not greater equal \NC \NR
\LL
\stoptabulate

This also applied to \prm {ifdim} although in the case of element we discard the
fractional part (read: divide the numeric representation by 65536).

\stopoldprimitive

\startnewprimitive[title={\prm {ifnumexpression}}]

Here is an example of a conditional using expressions:

\startbuffer
\ifnumexpression (\scratchcounterone > 5) and (\scratchcountertwo > 5) \relax
    do-something
\fi
\stopbuffer

This matches when the result is non zero, and you can mix calculations and tests
as with normal expressions.

\stopnewprimitive

\startnewprimitive[title={\prm {ifnumval}}]

This conditional is a variant on \prm {ifchknum}. This time we get
some more detail about the value:

\startbuffer
[-12  : \ifnumval  -12\or negative\or zero\or positive\else error\fi]\quad
[0    : \ifnumval    0\or negative\or zero\or positive\else error\fi]\quad
[12   : \ifnumval   12\or negative\or zero\or positive\else error\fi]\quad
[oeps : \ifnumval oeps\or negative\or zero\or positive\else error\fi]
\stopbuffer

\typebuffer

This gives:

{\getbuffer}

\stopnewprimitive

\startoldprimitive[title={\prm {ifodd}}]

One reason for this condition to be around is that in a double sided layout we
need test for being on an odd or even page. It scans for a number the same was
as other primitives,

\startbuffer
\ifodd65 YES \else NO\fi &
\ifodd`B YES \else NO\fi .
\stopbuffer

\typebuffer

So: {\inlinebuffer}

\stopoldprimitive

\startnewprimitive[title={\prm {ifparameter}}]

In a macro body \type {#1} is a reference to a parameter. You can check if one is
set using a dedicated parameter condition:

\startbuffer
\tolerant\def\foo[#1]#*[#2]%
  {\ifparameter#1\or one\else no one\fi\enspace
   \ifparameter#2\or two\else no two\fi\emspace}

\foo
\foo[1]
\foo[1][2]
\stopbuffer

\typebuffer

We get:

\getbuffer

\stopnewprimitive

% \startnewprimitive[title={\prm {ifparameters}}]
%     TODO
% \stopnewprimitive

\startnewprimitive[title={\prm {ifrelax}}]

This is a convenient shortcut for \typ {\ifx\relax} and the motivation for adding
this one is (as with some others) to get less tracing.

\stopnewprimitive

\startnewprimitive[title={\prm {iftok}}]

When you want to compare two arguments, the usual way to do this is the
following:

\starttyping
\edef\tempA{#1}
\edef\tempb{#2}
\ifx\tempA\tempB
    the same
\else
    different
\fi
\stoptyping

This works quite well but the fact that we need to define two macros can be
considered a bit of a nuisance. It also makes macros that use this method to be
not so called \quote {fully expandable}. The next one avoids both issues:

\starttyping
\iftok{#1}{#2}
    the same
\else
    different
\fi
\stoptyping

Instead of direct list you can also pass registers, so given:

\startbuffer[a]
\scratchtoks{a}%
\toks0{a}%
\stopbuffer

\typebuffer[a]

This:

\startbuffer[b]
\iftok 0 \scratchtoks          Y\else N\fi\space
\iftok{a}\scratchtoks          Y\else N\fi\space
\iftok\scratchtoks\scratchtoks Y\else N\fi
\stopbuffer

\typebuffer[b]

{\getbuffer[a]gives: \inlinebuffer[b].}

\stopnewprimitive

\startoldprimitive[title={\prm {iftrue}}]

Here we have a traditional \TEX\ conditional that is always true (therefore the
same is true for any macro that is \prm {let} to this primitive).

\stopoldprimitive

\startoldprimitive[title={\prm {ifvbox}}]

This traditional conditional checks if a given box register or internal box
variable represents a vertical box,

\stopoldprimitive

\startoldprimitive[title={\prm {ifvmode}}]

This traditional conditional checks we are in (internal) vertical mode.

\stopoldprimitive

\startoldprimitive[title={\prm {ifvoid}}]

This traditional conditional checks if a given box register or internal box
variable has any content.

\stopoldprimitive

\startoldprimitive[title={\prm {ifx}}]

We use this traditional \TEX\ conditional a lot in \CONTEXT. Contrary to \prm {if}
the two tokens that are compared are not expanded. This makes it possible to compare
the meaning of two macros. Depending on the need, these macros can have their content
expanded or not. A different number of parameters results in false.

Control sequences are identical when they have the same command code and
character code. Because a \prm {let} macro is just a reference, both let macros
are the same and equal to \prm {relax}:

\starttyping
\let\one\relax \let\two\relax
\stoptyping

The same is true for other definitions that result in the same (primitive) or
meaning encoded in the character field (think of \prm {chardef}s and so).

\stopoldprimitive

\startnewprimitive[title={\prm {ifzerodim}}]

This tests for a dimen (dimension) being zero so we have:

\starttyping
\ifdim<dimension>=0pt
\ifzerodim<dimension>
\ifcase<dimension register>
\stoptyping

\stopnewprimitive

% \startnewprimitive[title={\prm {ifzerofloat}}]
%     TODO
% \stopnewprimitive

\startnewprimitive[title={\prm {ifzeronum}}]

This tests for a number (integer) being zero so we have these variants now:

\starttyping
\ifnum<integer or equivalent>=0pt
\ifzeronum<integer or equivalent>
\ifcase<integer or equivalent>
\stoptyping

\stopnewprimitive

\startnewprimitive[title={\prm {ignorearguments}}]

This primitive will quit argument scanning and start expansion of the body of a
macro. The number of grabbed arguments can be tested as follows:

\startbuffer
\def\MyMacro[#1][#2][#3]%
 {\ifarguments zero\or one\or two\or three \else hm\fi}

\MyMacro          \ignorearguments \quad
\MyMacro       [1]\ignorearguments \quad
\MyMacro    [1][2]\ignorearguments \quad
\MyMacro [1][2][3]\ignorearguments \par
\stopbuffer

\typebuffer

{\getbuffer}

{\em Todo: explain optional delimiters.}

\stopnewprimitive

% \startnewprimitive[title={\prm {ignoredepthcriterion}}]
% \stopnewprimitive

\startnewprimitive[title={\prm {ignorenestedupto}}]

This primitive gobbles following tokens and can deal with nested \quote
{environments}, for example:

\startbuffer
\def\startfoo{\ignorenestedupto\startfoo\stopfoo}

(before
\startfoo
    test \startfoo test \stopfoo
   {test \startfoo test \stopfoo}
\stopfoo
after)
\stopbuffer

\typebuffer

delivers:

\getbuffer

\stopnewprimitive

\startnewprimitive[title={\prm {ignorepars}}]

This is a variant of \prm {ignorespaces}: following spaces {\em and} \type
{\par} equivalent tokens are ignored, so for instance:

\startbuffer
one + \ignorepars

two = \ignorepars \par
three
\stopbuffer

\typebuffer

renders as: \inlinebuffer. Traditionally \TEX\ has been sensitive to \prm {par}
tokens in some of its building blocks. This has to do with the fact that it could
indicate a runaway argument which in the times of slower machines and terminals
was best to catch early. In \LUAMETATEX\ we no longer have long macros and the
mechanisms that are sensitive can be told to accept \prm {par} tokens (and
\CONTEXT\ set them such that this is the case).

\stopnewprimitive

\startnewprimitive[title={\prm {ignorerest}}]

An example shows what this primitive does:

\startbuffer
\tolerant\def\foo[#1]#*[#2]%
  {1234
   \ifparameter#1\or\else
     \expandafter\ignorerest
   \fi
   /#1/
   \ifparameter#2\or\else
     \expandafter\ignorerest
   \fi
   /#2/ }

\foo test \foo[456] test \foo[456][789] test
\stopbuffer

\typebuffer

As this likely makes most sense in conditionals you need to make sure the current
state is properly finished. Because \prm {expandafter} bumps the input state,
here we actually quit two levels; this is because so called \quote {backed up
text} is intercepted by this primitive.

\getbuffer

\stopnewprimitive

\startoldprimitive[title={\prm {ignorespaces}}]

This traditional \TEX\ primitive signals the scanner to ignore the following
spaces, if any. We mention it because we show a companion in the next section.

\stopoldprimitive

\startnewprimitive[title={\prm {ignoreupto}}]

This ignores everything upto the given token, so

\startbuffer
\ignoreupto \foo not this but\foo only this
\stopbuffer

\typebuffer

will give: \inlinebuffer .

\stopnewprimitive

\startoldprimitive[title={\prm {immediate}}]

This one has no effect unless you intercept it at the \LUA\ end and act upon it.
In original \TEX\ immediate is used in combination with read from and write to
file operations. So, this is an old primitive with a new meaning.

\stopoldprimitive

\startnewprimitive[title={\prm {immutable}}]

This prefix flags what follows as being frozen and is usually applied to for
instance \prm {integerdef}'d control sequences. In that respect is is like \prm
{permanent} but it makes it possible to distinguish quantities from macros.

\stopnewprimitive

% \startoldprimitive[title={\prm {indent}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {indexofcharacter}}]
%     TODO
% \stopnewprimitive

% \startnewprimitive[title={\prm {indexofregister}}]
%     TODO
% \stopnewprimitive

% \startnewprimitive[title={\prm {inherited}}]
%     TODO
% \stopnewprimitive

\startnewprimitive[title={\prm {initcatcodetable}}]

This initializes the catcode table with the given index.

\stopnewprimitive

% \startnewprimitive[title={\prm {initialpageskip}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {initialtopskip}}]
% \stopnewprimitive

\startoldprimitive[title={\prm {input}}]

There are several ways to use this primitive:

\starttyping
\input  test
\input {test}
\input "test"
\input 'test'
\stoptyping

When no suffix is given, \TEX\ will assume the suffix is \type {.tex}. The second
one is normally used.

\stopoldprimitive

\startoldprimitive[title={\prm {inputlineno}}]

This integer holds the current linenumber but it is not always reliable.

\stopoldprimitive

% \startoldprimitive[title={\prm {insert}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {insertbox}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {insertcopy}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {insertdepth}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {insertdistance}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {insertheight}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {insertheights}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {insertlimit}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {insertmaxdepth}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {insertmode}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {insertmultiplier}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {insertpenalties}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {insertpenalty}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {insertprogress}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {insertstorage}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {insertstoring}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {insertunbox}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {insertuncopy}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {insertwidth}}]
% \stopnewprimitive

\startnewprimitive[title={\prm {instance}}]

This prefix flags a macro as an instance which is mostly relevant when a macro
package want to categorize macros.

\stopnewprimitive

\startnewprimitive[title={\prm {integerdef}}]

You can alias to a count (integer) register with \prm {countdef}:

\starttyping
\countdef\MyCount134
\stoptyping

Afterwards the next two are equivalent:

\starttyping
\MyCount   = 99
\count1234 = 99
\stoptyping

where \type {\MyCount} can be a bit more efficient because no index needs to be
scanned. However, in terms of storage the value (here 99) is always in the register
so \type {\MyCount} has to get there. This indirectness has the benefit that directly
setting the value is reflected in the indirect accessor.

\starttyping
\integerdef\MyCount = 99
\stoptyping

This primitive also defines a numeric equivalent but this time the number is stored
with the equivalent. This means that:

\starttyping
\let\MyCopyOfCount = \MyCount
\stoptyping

will store the {\em current} value of \type {\MyCount} in \type {\MyCopyOfCount} and
changing either of them is not reflected in the other.

The usual \prm {advance}, \prm {multiply} and \prm {divide} can be used with these
integers and they behave like any number. But compared to registers they are actually
more a constant.

\stopnewprimitive

\startoldprimitive[title={\prm {interactionmode}}]

This internal integer can be used to set or query the current interaction mode:

\starttabulate[|||]
\type {\batchmode    } \NC \the\batchmodecode     \NC \NR
\type {\nonstopmode  } \NC \the\nonstopmodecode   \NC \NR
\type {\scrollmode   } \NC \the\scrollmodecode    \NC \NR
\type {\errorstopmode} \NC \the\errorstopmodecode \NC \NR
\stoptabulate

% In \LUAMETATEX, for consistency, we have enabled these four as integers after
% \prm {the} but we can also decide to remove them and do this. So we leave this
% as an undocumented feature. It could have been an \ETEX\ way of abstracting the
% numeric values.
%
% \untraced\permanent\protected\def\batchmode    {\interactionmode\batchmodecode}
% \untraced\permanent\protected\def\nonstopmode  {\interactionmode\nonstopmodecode}
% \untraced\permanent\protected\def\scrollmode   {\interactionmode\scrollmodecode}
% \untraced\permanent\protected\def\errorstopmode{\interactionmode\errorstopmodecode}

\stopoldprimitive

% \startoldprimitive[title={\prm {interlinepenalties}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {interlinepenalty}}]
% \stopoldprimitive

\startoldprimitive[title={\prm {jobname}}]

This gives the current job name without suffix: {\tttf \jobname}.

\stopoldprimitive

% \startoldprimitive[title={\prm {kern}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {language}}]
% \stopoldprimitive

\startnewprimitive[title={\prm {lastarguments}}]

\startbuffer
\def\MyMacro    #1{\the\lastarguments (#1) }          \MyMacro{1}       \crlf
\def\MyMacro  #1#2{\the\lastarguments (#1) (#2)}      \MyMacro{1}{2}    \crlf
\def\MyMacro#1#2#3{\the\lastarguments (#1) (#2) (#3)} \MyMacro{1}{2}{3} \par

\def\MyMacro    #1{(#1)           \the\lastarguments} \MyMacro{1}       \crlf
\def\MyMacro  #1#2{(#1) (#2)      \the\lastarguments} \MyMacro{1}{2}    \crlf
\def\MyMacro#1#2#3{(#1) (#2) (#3) \the\lastarguments} \MyMacro{1}{2}{3} \par
\stopbuffer

\typebuffer

The value of \prm {lastarguments} can only be trusted in the expansion until
another macro is seen and expanded. For instance in these examples, as soon as a
character (like the left parenthesis) is seen, horizontal mode is entered and
\prm {everypar} is expanded which in turn can involve macros. You can see that
in the second block (that is: unless we changed \prm {everypar} in the
meantime).

{\getbuffer}

\stopnewprimitive

% \startnewprimitive[title={\prm {lastatomclass}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {lastboundary}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {lastbox}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {lastchkdimension}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {lastchknumber}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {lastkern}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {lastleftclass}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {lastlinefit}}]
% \stopoldprimitive

\startnewprimitive[title={\prm {lastloopiterator}}]

In addition to \prm {currentloopiterator} we have a variant that stores the value
in case an unexpanded loop is used:

\startbuffer
\localcontrolledrepeat 8 { [\the\currentloopiterator\eq\the\lastloopiterator] }
\expandedrepeat        8 { [\the\currentloopiterator\eq\the\lastloopiterator] }
\unexpandedrepeat      8 { [\the\currentloopiterator\ne\the\lastloopiterator] }
\stopbuffer

\typebuffer

\startlines
\getbuffer
\stoplines

\stopnewprimitive

\startnewprimitive[title={\prm {lastnamedcs}}]

The example code in the previous section has some redundancy, in the sense that
there to be looked up control sequence name \type {mymacro} is assembled twice.
This is no big deal in a traditional eight bit \TEX\ but in a \UNICODE\ engine
multi|-|byte sequences demand some more processing (although it is unlikely that
control sequences have many multi|-|byte \UTF8\ characters).

\starttyping
\ifcsname mymacro\endcsname
    \csname mymacro\endcsname
\fi
\stoptyping

Instead we can say:

\starttyping
\ifcsname mymacro\endcsname
    \lastnamedcs
\fi
\stoptyping

Although there can be some performance benefits another advantage is that it uses
less tokens and parsing. It might even look nicer.

\stopnewprimitive

% \startnewprimitive[title={\prm {lastnodesubtype}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {lastnodetype}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {lastpageextra}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {lastparcontext}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {lastpenalty}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {lastrightclass}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {lastskip}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {lccode}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {leaders}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {left}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {lefthyphenmin}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {leftmarginkern}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {leftskip}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {leqno}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {let}}]
% \stopoldprimitive

\startnewprimitive[title={\prm {letcharcode}}]

Assigning a meaning to an active character can sometimes be a bit cumbersome;
think of using some documented uppercase magic that one tends to forget as it's
used only a few times and then never looked at again. So we have this:

\startbuffer
{\letcharcode 65 1 \catcode 65 13 A : \meaning A}\crlf
{\letcharcode 65 2 \catcode 65 13 A : \meaning A}\par
\stopbuffer

\typebuffer

here we define \type {A} as an active charcter with meaning \type {1} in the
first line and \type {2} in the second.

{\tttf \getbuffer}

Normally one will assign a control sequence:

\startbuffer
{\letcharcode 66 \bf \catcode 66 13 {B   bold}: \meaning B}\crlf
{\letcharcode 73 \it \catcode 73 13 {I italic}: \meaning I}\par
\stopbuffer

\typebuffer

Of course \type {\bf} and \type {\it} are \CONTEXT\ specific commands:

{\tttf \getbuffer}

\stopnewprimitive

\startnewprimitive[title={\prm {letcsname}}]

It is easy to see that we save two tokens when we use this primitive. As with the
\type {..defcs..} variants it also saves a push back of the composed macro name.

\starttyping
\expandafter\let\csname MyMacro:1\endcsname\relax
             \letcsname MyMacro:1\endcsname\relax
\stoptyping

\stopnewprimitive

\startnewprimitive[title={\prm {letfrozen}}]

You can explicitly freeze an unfrozen macro:

\starttyping
\def\MyMacro{...}
\letfrozen\MyMacro
\stoptyping

A redefinition will now give:

\starttyping
! You can't redefine a frozen macro.
\stoptyping

\stopnewprimitive

% \startnewprimitive[title={\prm {letmathatomrule}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {letmathparent}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {letmathspacing}}]
% \stopnewprimitive

\startnewprimitive[title={\prm {letprotected}}]

Say that you have these definitions:

\startbuffer
             \def  \MyMacroA{alpha}
\protected   \def  \MyMacroB{beta}
             \edef \MyMacroC{\MyMacroA\MyMacroB}
\letprotected      \MyMacroA
             \edef \MyMacroD{\MyMacroA\MyMacroB}
\meaning           \MyMacroC\crlf
\meaning           \MyMacroD\par
\stopbuffer

\typebuffer

The typeset meaning in this example is:

{\tttf \getbuffer}

\stopnewprimitive

\startnewprimitive[title={\prm {lettolastnamedcs}}]

The \prm {lastnamedcs} primitive is somewhat special as it is a (possible)
reference to  a control sequence which is why we have a dedicated variant of
\prm {let}.

\startbuffer
\csname relax\endcsname\let                         \foo\lastnamedcs \meaning\foo
\csname relax\endcsname\expandafter\let\expandafter \oof\lastnamedcs \meaning\oof
\csname relax\endcsname\lettolastnamedcs            \ofo             \meaning\ofo
\stopbuffer

\typebuffer % we need oneliners because intermediate csnames kick in

These give the following where the first one obviously is not doing what we want
and the second one is kind of cumbersome.

\startlines
\getbuffer
\stoplines

\stopnewprimitive

\startnewprimitive[title={\prm {lettonothing}}]

This one let's a control sequence to nothing. Assuming that \tex {empty}
is indeed empty, these two lines are equivalent.

\starttyping
\let         \foo\empty
\lettonothing\oof
\stoptyping

\stopnewprimitive

% \startoldprimitive[title={\prm {limits}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {linebreakcriterion}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {linebreakoptional}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {linebreakpasses}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {linedirection}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {linepenalty}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {lineskip}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {lineskiplimit}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {localbrokenpenalty}}]
% \stopnewprimitive

\startnewprimitive[title={\prm {localcontrol}}]

This primitive takes a single token:

\startbuffer
\edef\testa{\scratchcounter123 \the\scratchcounter}
\edef\testc{\testa \the\scratchcounter}
\edef\testd{\localcontrol\testa \the\scratchcounter}
\stopbuffer

\typebuffer

The three meanings are:

\start \getbuffer
\starttabulate[|T|T|]
\NC \string\testa \NC \meaning\testa \NC \NR
\NC \string\testc \NC \meaning\testc \NC \NR
\NC \string\testd \NC \meaning\testd \NC \NR
\stoptabulate
\stop

The \prm {localcontrol} makes that the following token gets expanded so we don't
see the yet to be expanded assignment show up in the macro body.

\stopnewprimitive

\startnewprimitive[title={\prm {localcontrolled}}]

The previously described local control feature comes with two extra helpers. The
\prm {localcontrolled} primitive takes a token list and wraps this into a local
control sidetrack. For example:

\startbuffer
\edef\testa{\scratchcounter123 \the\scratchcounter}
\edef\testb{\localcontrolled{\scratchcounter123}\the\scratchcounter}
\stopbuffer

\typebuffer

The two meanings are:

\start \getbuffer
\starttabulate[|T|T|]
\NC \string\testa \NC \meaningfull\testa \NC \NR
\NC \string\testb \NC \meaningfull\testb \NC \NR
\stoptabulate
\stop

The assignment is applied immediately in the expanded definition.

\stopnewprimitive

\startnewprimitive[title={\prm {localcontrolledendless}}]

As the name indicates this will loop forever. You need to explicitly quit the
loop with \prm {quitloop} or \prm {quitloopnow}. The first quitter aborts the
loop at the start of a next iteration, the second one tries to exit immediately,
but is sensitive for interference with for instance nested conditionals.

\stopnewprimitive

\startnewprimitive[title={\prm {localcontrolledloop}}]

As with more of the primitives discussed here, there is a manual in the \quote
{lowlevel} subset that goes into more detail. So, here a simple example has to
do:

\startbuffer
\localcontrolledloop 1 100 1 {%
    \ifnum\currentloopiterator>6\relax
        \quitloop
    \else
        [\number\currentloopnesting:\number\currentloopiterator]
        \localcontrolledloop 1 8 1 {%
            (\number\currentloopnesting:\number\currentloopiterator)
        }\par
    \fi
}
\stopbuffer

\typebuffer

Here we see the main loop primitive being used nested. The code shows how we can
\prm {quitloop} and have access to the \prm {currentloopiterator} as well as the
nesting depth \prm {currentloopnesting}.

\startpacked \getbuffer \stoppacked

Be aware of the fact that \prm {quitloop} will end the loop at the {\em next}
iteration so any content after it will show up. Normally this one will be issued
in a condition and we want to end that properly. Also keep in mind that because
we use local control (a nested \TEX\ expansion loop) anything you feed back can
be injected out of order.

The three numbers can be separated by an equal sign which is a trick to avoid
look ahead issues that can result from multiple serialized numbers without spaces
that indicate the end of sequence of digits.

\stopnewprimitive

\startnewprimitive[title={\prm {localcontrolledrepeat}}]

This one takes one instead three arguments which looks a bit better
in simple looping.

\stopnewprimitive

% \startnewprimitive[title={\prm {localinterlinepenalty}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {localleftbox}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {localleftboxbox}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {localmiddlebox}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {localmiddleboxbox}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {localpretolerance}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {localrightbox}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {localrightboxbox}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {localtolerance}}]
% \stopnewprimitive

\startoldprimitive[title={\prm {long}}]

This original prefix gave the macro being defined the property that it could not
have \prm {par} (or the often equivalent empty lines) in its arguments. It was
mostly a protection against a forgotten right curly brace, resulting in a so called
run|-|away argument. That mattered on a paper terminal or slow system where such a
situation should be catched early. In \LUATEX\ it was already optional, and in
\LUAMETATEX\ we dropped this feature completely (so that we could introduce others).

\stopoldprimitive

% \startoldprimitive[title={\prm {looseness}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {lower}}]
% \stopoldprimitive

\startoldprimitive[title={\prm {lowercase}}]

This token processor converts character tokens to their lowercase counterparts as
defined per \prm {lccode}. In order to permit dirty tricks active characters are
also processed. We don't really use this primitive in \CONTEXT, but for
consistency we let it respond to \prm {expand}: \footnote {Instead of providing
\type {\lowercased} and \type {\uppercased} primitives that would clash with
macros anyway.}

\startbuffer
\edef           \foo       {\lowercase{tex TeX \TEX}} \meaningless\foo
\lowercase{\edef\foo                  {tex TeX \TEX}} \meaningless\foo
\edef           \foo{\expand\lowercase{tex TeX \TEX}} \meaningless\foo
\stopbuffer

\typebuffer

Watch how \prm {lowercase} is not expandable but can be forced to. Of course, as
the logo macro is protected the \TEX\ logo remains mixed case.

\startlines
\getbuffer
\stoplines

\stopoldprimitive

% \startnewprimitive[title={\prm {lpcode}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {luabytecode}}]
%     TODO
% \stopnewprimitive

% \startnewprimitive[title={\prm {luabytecodecall}}]
%     TODO
% \stopnewprimitive

% \startnewprimitive[title={\prm {luacopyinputnodes}}]
%     TODO
% \stopnewprimitive

% \startnewprimitive[title={\prm {luadef}}]
%     TODO
% \stopnewprimitive

\startnewprimitive[title={\prm {luaescapestring}}]

This command converts the given (token) list into something that is acceptable
for \LUA. It is inherited from \LUATEX\ and not used in \CONTEXT.

\startbuffer
\directlua { tex.print ("\luaescapestring {{\tt This is a "test".}}") }
\stopbuffer

\typebuffer

Results in: \inlinebuffer\space (Watch the grouping.)

\stopnewprimitive

% \startnewprimitive[title={\prm {luafunction}}]
%     TODO
% \stopnewprimitive

% \startnewprimitive[title={\prm {luafunctioncall}}]
%     TODO
% \stopnewprimitive

\startnewprimitive[title={\prm {luatexbanner}}]

This gives: {\tttf \luatexbanner}.

\stopnewprimitive

\startnewprimitive[title={\prm {luatexrevision}}]

This is an integer. The current value is: {\tttf \number\luatexrevision}.

\stopnewprimitive

\startnewprimitive[title={\prm {luatexversion}}]

This is an integer. The current value is: {\tttf \number\luatexversion}.

\stopnewprimitive

% \startoldprimitive[title={\prm {mark}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {marks}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {mathaccent}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {mathatom}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathatomglue}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathatomskip}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathbackwardpenalties}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathbeginclass}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {mathbin}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {mathboundary}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {mathchar}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {mathchardef}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {mathcheckfencesmode}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {mathchoice}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {mathclose}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {mathcode}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {mathdictgroup}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathdictproperties}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathdirection}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathdisplaymode}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathdisplaypenaltyfactor}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathdisplayskipmode}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathdoublescriptmode}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathendclass}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {matheqnogapstep}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathfontcontrol}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathforwardpenalties}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathgluemode}}]
% \stopnewprimitive

\startnewprimitive[title={\prm {mathgroupingmode}}]

Normally a \type {{}} or \type {\bgroup}|-|\type {\egroup} pair in math create a
math list. However, users are accustomed to using it also for grouping and then a
list being created might not be what a user wants. As an alternative to the more
verbose \prm {begingroup}|-|\prm {endgroup} or even less sensitive \prm
{beginmathgroup}|-|\prm {endmathgroup} you can set the math grouping mode to a
non zero value which makes curly braces (and the aliases) behave as expected.

\stopnewprimitive

% \startnewprimitive[title={\prm {mathinlinepenaltyfactor}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {mathinner}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {mathleftclass}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathlimitsmode}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathmainstyle}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathnolimitsmode}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {mathop}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {mathopen}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {mathord}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {mathpenaltiesmode}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathpretolerance}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {mathpunct}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {mathrel}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {mathrightclass}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathrulesfam}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathrulesmode}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathscale}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathscriptsmode}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathslackmode}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathspacingmode}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathstackstyle}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathstyle}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathstylefontid}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {mathsurround}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {mathsurroundmode}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathsurroundskip}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {maththreshold}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {mathtolerance}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {maxdeadcycles}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {maxdepth}}]
% \stopoldprimitive

\startoldprimitive[title={\prm {meaning}}]

We start with a primitive that will be used in the following sections. The
reported meaning can look a bit different than the one reported by other engines
which is a side effect of additional properties and more extensive argument
parsing.

\startbuffer
\tolerant\permanent\protected\gdef\foo[#1]#*[#2]{(#1)(#2)} \meaning\foo
\stopbuffer

\typebuffer \getbuffer

\stopoldprimitive

\startnewprimitive[title={\prm {meaningasis}}]

Although it is not really round trip with the original due to information
being lost this primitive tries to return an equivalent definition.

\startbuffer
\tolerant\permanent\protected\gdef\foo[#1]#*[#2]{(#1)(#2)} \meaningasis\foo
\stopbuffer

\typebuffer \getbuffer

\stopnewprimitive

\startnewprimitive[title={\prm {meaningful}}]

This one reports a bit less than \prm {meaningful}.

\startbuffer
\tolerant\permanent\protected\gdef\foo[#1]#*[#2]{(#1)(#2)} \meaningful\foo
\stopbuffer

\typebuffer \getbuffer

\stopnewprimitive

\startnewprimitive[title={\prm {meaningfull}}]

This one reports a bit more than \prm {meaning}.

\startbuffer
\tolerant\permanent\protected\gdef\foo[#1]#*[#2]{(#1)(#2)} \meaningfull\foo
\stopbuffer

\typebuffer \getbuffer

\stopnewprimitive

\startnewprimitive[title={\prm {meaningles}}]

This one reports a bit less than \prm {meaningless}.

\startbuffer
\tolerant\permanent\protected\gdef\foo[#1]#*[#2]{(#1)(#2)} \meaningles\foo
\stopbuffer

\typebuffer \getbuffer

\stopnewprimitive

\startnewprimitive[title={\prm {meaningless}}]

This one reports a bit less than \prm {meaning}.

\startbuffer
\tolerant\permanent\protected\gdef\foo[#1]#*[#2]{(#1)(#2)} \meaningless\foo
\stopbuffer

\typebuffer \getbuffer

\stopnewprimitive

% \startoldprimitive[title={\prm {medmuskip}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {message}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {middle}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {mkern}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {month}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {moveleft}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {moveright}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {mskip}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {muexpr}}]
%     TODO
% \stopoldprimitive

\startnewprimitive[title={\prm {mugluespecdef}}]

A variant of \prm {gluespecdef} that expects \type {mu} units is:

\starttyping
\mugluespecdef\MyGlue = 3mu plus 2mu minus 1mu
\stoptyping

The properties are comparable to the ones described in the previous sections.

\stopnewprimitive

\startoldprimitive[title={\prm {multiply}}]

The given quantity is multiplied by the given integer (that can be preceded by
the keyword \quote {by}, like:

\starttyping
\scratchdimen=10pt \multiply\scratchdimen by 3
\stoptyping

\stopoldprimitive

\startnewprimitive[title={\prm {multiplyby}}]

This is slightly more efficient variant of \prm {multiply} that doesn't look for
\type {by}. See previous section.

\stopnewprimitive

% \startoldprimitive[title={\prm {muskip}}]
%     TODO
% \stopoldprimitive

% \startoldprimitive[title={\prm {muskipdef}}]
%     TODO
% \stopoldprimitive

% \startnewprimitive[title={\prm {mutable}}]
%     TODO
% \stopnewprimitive

% \startoldprimitive[title={\prm {mutoglue}}]
%     TODO
% \stopoldprimitive

% \startnewprimitive[title={\prm {nestedloopiterator}}]
%     TODO
% \stopnewprimitive

% \startoldprimitive[title={\prm {newlinechar}}]
%     TODO
% \stopoldprimitive

% \startoldprimitive[title={\prm {noalign}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {noaligned}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {noatomruling}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {noboundary}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {noexpand}}]
%     TODO
% \stopoldprimitive

% \startnewprimitive[title={\prm {nohrule}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {noindent}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {nolimits}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {nonscript}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {nonstopmode}}]
%     TODO
% \stopoldprimitive

\startnewprimitive[title={\prm {norelax}}]

The rationale for this command can be shown by a few examples:

\startbuffer
\dimen0 1pt \dimen2 1pt \dimen4 2pt
\edef\testa{\ifdim\dimen0=\dimen2\norelax N\else Y\fi}
\edef\testb{\ifdim\dimen0=\dimen2\relax   N\else Y\fi}
\edef\testc{\ifdim\dimen0=\dimen4\norelax N\else Y\fi}
\edef\testd{\ifdim\dimen0=\dimen4\relax   N\else Y\fi}
\edef\teste{\norelax}
\stopbuffer

\typebuffer

The five meanings are:

\start \getbuffer \starttabulate[|T|T|]
\NC \string\testa \NC \meaning\testa \NC \NR
\NC \string\testb \NC \meaning\testb \NC \NR
\NC \string\testc \NC \meaning\testc \NC \NR
\NC \string\testd \NC \meaning\testd \NC \NR
\NC \string\teste \NC \meaning\teste \NC \NR
\stoptabulate \stop

So, the \prm {norelax} acts like \prm {relax} but is not pushed back as
usual (in some cases).

\stopnewprimitive

% \startnewprimitive[title={\prm {normalizelinemode}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {normalizeparmode}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {nospaces}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {novrule}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {nulldelimiterspace}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {nullfont}}]
% \stopoldprimitive

\startoldprimitive[title={\prm {number}}]

This \TEX\ primitive serializes the next token into a number, assuming that it
is indeed a number, like

\starttyping
\number`A
\number65
\number\scratchcounter
\stoptyping

For counters and such the \prm {the} primitive does the same, but when you're
not sure if what follows is a verbose number or (for instance) a counter the
\prm {number} primitive is a safer bet, because \type {\the 65} will not work.

\stopoldprimitive

\startnewprimitive[title={\prm {numericscale}}]

This primitive can best be explained by a few examples:

\startbuffer
\the\numericscale 1323
\the\numericscale 1323.0
\the\numericscale 1.323
\the\numericscale 13.23
\stopbuffer

\typebuffer

In several places \TEX\ uses a scale but due to the lack of floats it then uses
1000 as 1.0 replacement. This primitive can be used for \quote {real} scales and
the period signals this:

\startlines \getbuffer \stoplines

When there is a period (indicating the fraction) the result is an integer (count)
that has the multiplier 1000 applied.

\stopnewprimitive

% \startnewprimitive[title={\prm {numericscaled}}]
%     TODO
% \stopnewprimitive

% \startoldprimitive[title={\prm {numexpr}}]
%     TODO
% \stopoldprimitive

\startnewprimitive[title={\prm {numexpression}}]

The normal \prm {numexpr} primitive understands the \type {+}, \type {-}, \type
{*} and \type {/} operators but in \LUAMETATEX\ we also can use \type {:} for a
non rounded integer division (think of \LUA's \type {//}). if you want more than
that, you can use the new expression primitive where you can use the following
operators.

\starttabulate[||cT|cT|]
\BC add       \NC +                    \NC        \NC \NR
\BC subtract  \NC -                    \NC        \NC \NR
\BC multiply  \NC *                    \NC        \NC \NR
\BC divide    \NC / :                  \NC        \NC \NR
\BC mod       \NC \letterpercent       \NC mod    \NC \NR
\BC band      \NC &                    \NC band   \NC \NR
\BC bxor      \NC ^                    \NC bxor   \NC \NR
\BC bor       \NC \letterbar \space v  \NC bor    \NC \NR
\BC and       \NC &&                   \NC and    \NC \NR
\BC or        \NC \letterbar\letterbar \NC or     \NC \NR
\BC setbit    \NC <undecided>          \NC bset   \NC \NR
\BC resetbit  \NC <undecided>          \NC breset \NC \NR
\BC left      \NC <<                   \NC        \NC \NR
\BC right     \NC >>                   \NC        \NC \NR
\BC less      \NC <                    \NC        \NC \NR
\BC lessequal \NC <=                   \NC        \NC \NR
\BC equal     \NC = ==                 \NC        \NC \NR
\BC moreequal \NC >=                   \NC        \NC \NR
\BC more      \NC >                    \NC        \NC \NR
\BC unequal   \NC <> != \lettertilde = \NC        \NC \NR
\BC not       \NC ! \lettertilde       \NC not    \NC \NR
\stoptabulate

An example of the verbose bitwise operators is:

\starttyping
\scratchcounter = \numexpression
    "00000 bor "00001 bor "00020 bor "00400 bor "08000 bor "F0000
\relax
\stoptyping

In the table you might have notices that some operators have equivalents. This
makes the scanner a bit less sensitive for catcode regimes.

When \prm {tracingexpressions} is set to one or higher the intermediate \quote
{reverse polish notation} stack that is used for the calculation is shown, for
instance:

\starttyping
4:8: {numexpression rpn: 2 5 > 4 5 > and}
\stoptyping

When you want the output on your console, you need to say:

\starttyping
\tracingexpressions 1
\tracingonline      1
\stoptyping

\stopnewprimitive

% \startoldprimitive[title={\prm {omit}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {optionalboundary}}]
% \stopnewprimitive

\startoldprimitive[title={\prm {or}}]

This traditional primitive is part of the condition testing mechanism and relates
to an \prm {ifcase} test (or a similar test to be introduced in later
sections). Depending on the value, \TEX\ will do a fast scanning till the right
\prm {or} is seen, then it will continue expanding till it sees a \prm {or}
or \prm {else} or \prm {orelse} (to be discussed later). It will then do a
fast skipping pass till it sees an \prm {fi}.

\stopoldprimitive

\startnewprimitive[title={\prm {orelse}}]

This primitive provides a convenient way to flatten your conditional tests. So
instead of

\starttyping
\ifnum\scratchcounter<-10
    too small
\else\ifnum\scratchcounter>10
    too large
\else
    just right
\fi\fi
\stoptyping

You can say this:

\starttyping
\ifnum\scratchcounter<-10
    too small
\orelse\ifnum\scratchcounter>10
    too large
\else
    just right
\fi
\stoptyping

You can mix tests and even the case variants will work in most cases \footnote {I
just play safe because there are corner cases that might not work yet.}

\starttyping
\ifcase\scratchcounter          zero
\or                             one
\or                             two
\orelse\ifnum\scratchcounter<10 less than ten
\else                           ten or more
\fi
\stoptyping

Performance wise there are no real benefits although in principle there is a bit
less housekeeping involved than with nested checks. However you might like this:

\starttyping
\ifnum\scratchcounter<-10
    \expandafter\toosmall
\orelse\ifnum\scratchcounter>10
    \expandafter\toolarge
\else
    \expandafter\justright
\fi
\stoptyping

over:

\starttyping
\ifnum\scratchcounter<-10
    \expandafter\toosmall
\else\ifnum\scratchcounter>10
    \expandafter\expandafter\expandafter\toolarge
\else
    \expandafter\expandafter\expandafter\justright
\fi\fi
\stoptyping

or the more \CONTEXT\ specific:

\starttyping
\ifnum\scratchcounter<-10
    \expandafter\toosmall
\else\ifnum\scratchcounter>10
    \doubleexpandafter\toolarge
\else
    \doubleexpandafter\justright
\fi\fi
\stoptyping

But then, some \TEX ies like complex and obscure code and throwing away working
old code that took ages to perfect and get working and also showed that one
masters \TEX\ might hurt.

\stopnewprimitive

% \startnewprimitive[title={\prm {orphanpenalties}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {orphanpenalty}}]
% \stopnewprimitive

\startnewprimitive[title={\prm {orunless}}]

This is the negated variant of \prm {orelse} (prefixing that one with \tex
{unless} doesn't work well.

\stopnewprimitive

\startoldprimitive[title={\prm {outer}}]

An outer macro is one that can only be used at the outer level. This property is
no longer supported. Like \prm {long}, the \prm {outer} prefix is now an
no|-|op (and we don't expect this to have unfortunate side effects).

\stopoldprimitive

% \startoldprimitive[title={\prm {output}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {outputbox}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {outputpenalty}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {over}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {overfullrule}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {overline}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {overloaded}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {overloadmode}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {overshoot}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {overwithdelims}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {pageboundary}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {pagedepth}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {pagediscards}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {pageexcess}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {pageextragoal}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {pagefilllstretch}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {pagefillstretch}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {pagefilstretch}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {pagefistretch}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {pagegoal}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {pagelastdepth}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {pagelastfilllstretch}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {pagelastfillstretch}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {pagelastfilstretch}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {pagelastheight}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {pagelastshrink}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {pagelaststretch}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {pageshrink}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {pagestretch}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {pagetotal}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {pagevsize}}]
% \stopnewprimitive

\startoldprimitive[title={\prm {par}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {parametercount}}]
%     TODO
% \stopnewprimitive

\startnewprimitive[title={\prm {parameterdef}}]

Here is an example of binding a variable to a parameter. The alternative is of
course to use an \prm {edef}.

\startbuffer
\def\foo#1#2%
  {\parameterdef\MyIndexOne\plusone % 1
   \parameterdef\MyIndexTwo\plustwo % 2
   \oof{P}\oof{Q}\oof{R}\norelax}

\def\oof#1%
  {<1:\MyIndexOne><1:\MyIndexOne>%
   #1%
   <2:\MyIndexTwo><2:\MyIndexTwo>}

\foo{A}{B}
\stopbuffer

\typebuffer

The outcome is:

\getbuffer

\stopnewprimitive

\startnewprimitive[title={\prm {parameterindex}}]

This gives the zero based position on the parameter stack. One reason for
introducing \prm {parameterdef} is that the position remains abstract so there we
don't need to use \prm {parameterindex}.

\stopnewprimitive

\startnewprimitive[title={\prm {parametermark}}]

This is an equivalent for \type {#}.

\stopnewprimitive

\startnewprimitive[title={\prm {parametermode}}]

Setting this internal integer to a positive value (best use~1 because future
versions might use bit set) will enable the usage of \type {#} for escaped in the
main text and body of macros.

\stopnewprimitive

% \startnewprimitive[title={\prm {parattribute}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {pardirection}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {parfillleftskip}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {parfillrightskip}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {parfillskip}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {parindent}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {parinitleftskip}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {parinitrightskip}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {parpasses}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {parshape}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {parshapedimen}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {parshapeindent}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {parshapelength}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {parskip}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {patterns}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {pausing}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {penalty}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {permanent}}]
%     TODO
% \stopnewprimitive

% \startnewprimitive[title={\prm {pettymuskip}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {positdef}}]
%     TODO
% \stopnewprimitive

% \startoldprimitive[title={\prm {postdisplaypenalty}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {postexhyphenchar}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {posthyphenchar}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {postinlinepenalty}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {postshortinlinepenalty}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {prebinoppenalty}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {predisplaydirection}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {predisplaygapfactor}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {predisplaypenalty}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {predisplaysize}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {preexhyphenchar}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {prehyphenchar}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {preinlinepenalty}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {prerelpenalty}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {preshortinlinepenalty}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {pretolerance}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {prevdepth}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {prevgraf}}]
% \stopoldprimitive

\startnewprimitive[title={\prm {previousloopiterator}}]

\startbuffer
\edef\testA{
    \expandedrepeat 2 {%
        \expandedrepeat 3 {%
            (\the\previousloopiterator1:\the\currentloopiterator)
        }%
    }%
}
\edef\testB{
    \expandedrepeat 2 {%
        \expandedrepeat 3 {%
            (#P:#I) % #G is two levels up
        }%
    }%
}
\stopbuffer

\typebuffer \getbuffer

These give the same result:

\startlines \tt
\meaningasis\testA
\meaningasis\testB
\stoplines

The number indicates the number of levels we go up the loop chain.

\stopnewprimitive

\startoldprimitive[title={\prm {protected}}]

A protected macro is one that doesn't get expanded unless it is time to do so.
For instance, inside an \prm {edef} it just stays what it is. It often makes
sense to pass macros as|-|is to (multi|-|pass) file (for tables of contents).

In \CONTEXT\ we use either \prm {protected} or \prm {unexpanded} because the
later was the command we used to achieve the same results before \ETEX\
introduced this protection primitive. Originally the \prm {protected} macro was
also defined but it has been dropped.

\stopoldprimitive

\startnewprimitive[title={\prm {protecteddetokenize}}]

This is a variant of \prm {protecteddetokenize} that uses some escapes encoded as
body parameters, like \type {#H} for a hash.

\stopnewprimitive

\startnewprimitive[title={\prm {protectedexpandeddetokenize}}]

This is a variant of \prm {expandeddetokenize} that uses some escapes encoded as
body parameters, like \type {#H} for a hash.

\stopnewprimitive


% \startnewprimitive[title={\prm {protrudechars}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {protrusionboundary}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {pxdimen}}]
%     TODO
% \stopnewprimitive

% \startnewprimitive[title={\prm {quitloop}}]
%     TODO
% \stopnewprimitive

% \startnewprimitive[title={\prm {quitloopnow}}]
%     TODO
% \stopnewprimitive

% \startnewprimitive[title={\prm {quitvmode}}]
%     TODO
% \stopnewprimitive

% \startoldprimitive[title={\prm {radical}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {raise}}]
% \stopoldprimitive

\startnewprimitive[title={\prm {rdivide}}]

This is variant of \prm {divide} that rounds the result. For integers the result
is the same as \prm {edivide}.

\startbuffer
\the\dimexpr .4999pt                     : 2 \relax            =.24994pt
\the\dimexpr .4999pt                     / 2 \relax            =.24995pt
\scratchdimen.4999pt \divide \scratchdimen 2 \the\scratchdimen =.24994pt
\scratchdimen.4999pt \edivide\scratchdimen 2 \the\scratchdimen =.24995pt
\scratchdimen 4999pt \rdivide\scratchdimen 2 \the\scratchdimen =2500.0pt
\scratchdimen 5000pt \rdivide\scratchdimen 2 \the\scratchdimen =2500.0pt

\the\numexpr   1001                       : 2 \relax             =500
\the\numexpr   1001                       / 2 \relax             =501
\scratchcounter1001 \divide \scratchcounter 2 \the\scratchcounter=500
\scratchcounter1001 \edivide\scratchcounter 2 \the\scratchcounter=501
\scratchcounter1001 \rdivide\scratchcounter 2 \the\scratchcounter=501
\stopbuffer

\typebuffer

\startlines
\getbuffer
\stoplines

\stopnewprimitive

\startnewprimitive[title={\prm {rdivideby}}]

This is the \type {by}|-|less companion to \prm {rdivide}.

\stopnewprimitive

\startoldprimitive[title={\prm {relax}}]

This primitive does nothing and is often used to end a verbose number or
dimension in a comparison, for example:

\starttyping
\ifnum \scratchcounter = 123\relax
\stoptyping

which prevents a lookahead. A variant would be:

\starttyping
\ifnum \scratchcounter = 123 %
\stoptyping

assuming that spaces are not ignored. Another application is finishing
an expression like \prm {numexpr} or \prm {dimexpr}. I is also used
to prevent lookahead in cases like:

\starttyping
\vrule height 3pt depth 2pt width 5pt\relax
\hskip 5pt plus 3pt minus 2pt\relax
\stoptyping

Because \prm {relax} is not expandable the following:

\startbuffer
\edef\foo{\relax}   \meaningfull\foo
\edef\oof{\norelax} \meaningfull\oof
\stopbuffer

\typebuffer

gives this:

\startlines
\getbuffer
\stoplines

A \prm {norelax} disappears here but in the previously mentioned scenarios
it has the same function as \prm {relax}. It will not be pushed back either
in cases where a lookahead demands that.

\stopoldprimitive

% \startoldprimitive[title={\prm {relpenalty}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {resetmathspacing}}]
% \stopnewprimitive

\startnewprimitive[title={\prm {retained}}]

When a value is assigned inside a group \TEX\ pushes the current value on the save
stack in order to be able to restore the original value after the group has ended. You
can reach over a group by using the \prm {global} prefix. A mix between local and
global assignments can be achieved with the \prm {retained} primitive.

\newdimension\MyDim

\startbuffer[one]
\MyDim 15pt \bgroup \the\MyDim \space
\bgroup
    \bgroup
        \bgroup \advance\MyDim10pt \the\MyDim \egroup\space
        \bgroup \advance\MyDim10pt \the\MyDim \egroup\space
    \egroup
    \bgroup
        \bgroup \advance\MyDim10pt \the\MyDim \egroup\space
        \bgroup \advance\MyDim10pt \the\MyDim \egroup\space
    \egroup
\egroup
\egroup \the\MyDim
\stopbuffer

\startbuffer[two]
\MyDim 15pt \bgroup \the\MyDim \space
\bgroup
    \bgroup
        \bgroup \global\advance\MyDim10pt \the\MyDim \egroup\space
        \bgroup \global\advance\MyDim10pt \the\MyDim \egroup\space
    \egroup
    \bgroup
        \bgroup \global\advance\MyDim10pt \the\MyDim \egroup\space
        \bgroup \global\advance\MyDim10pt \the\MyDim \egroup\space
    \egroup
\egroup
\egroup \the\MyDim
\stopbuffer

\startbuffer[three]
\MyDim 15pt \bgroup \the\MyDim \space
    \constrained\MyDim\zeropoint
    \bgroup
        \bgroup \retained\advance\MyDim10pt \the\MyDim \egroup\space
        \bgroup \retained\advance\MyDim10pt \the\MyDim \egroup\space
    \egroup
    \bgroup
        \bgroup \retained\advance\MyDim10pt \the\MyDim \egroup\space
        \bgroup \retained\advance\MyDim10pt \the\MyDim \egroup\space
    \egroup
\egroup \the\MyDim
\stopbuffer

\typebuffer[one,two,three]

These lines result in:

\startlines
\hbox{\getbuffer[one]}
\hbox{\getbuffer[two]}
\hbox{\getbuffer[three]}
\stoplines

Because \LUAMETATEX\ avoids redundant stack entries and reassignments this
mechanism is a bit fragile but the \prm {constrained} prefix makes sure that we
do have a stack entry. If it is needed depends on the usage pattern.

\stopnewprimitive

\startnewprimitive[title={\prm {retokenized}}]

This is a companion of \prm {tokenized} that accepts a catcode table, so the
whole repertoire is:

\startbuffer
\tokenized                             {test $x$ test: current}
\tokenized   catcodetable \ctxcatcodes {test $x$ test: context}
\tokenized   catcodetable \vrbcatcodes {test $x$ test: verbatim}
\retokenized              \ctxcatcodes {test $x$ test: context}
\retokenized              \vrbcatcodes {test $x$ test: verbatim}
\stopbuffer

\typebuffer

Here we pass the numbers known to \CONTEXT\ and get:

\startlines
\getbuffer
\stoplines

\stopnewprimitive

% \startoldprimitive[title={\prm {right}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {righthyphenmin}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {rightmarginkern}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {rightskip}}]
% \stopoldprimitive

\startoldprimitive[title={\prm {romannumeral}}]

This converts a number into a sequence of characters representing a roman
numeral. Because the Romans had no zero, a zero will give no output, a fact that
is sometimes used for hacks and showing off ones macro coding capabilities. A
large number will for sure result in a long string because after thousand we
start duplicating.

\stopoldprimitive

% \startnewprimitive[title={\prm {rpcode}}]
% \stopnewprimitive

\startnewprimitive[title={\prm {savecatcodetable}}]

This primitive stores the currently set catcodes in the current table.

\stopnewprimitive

% \startoldprimitive[title={\prm {savinghyphcodes}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {savingvdiscards}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {scaledemwidth}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {scaledexheight}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {scaledextraspace}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {scaledfontcharba}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {scaledfontchardp}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {scaledfontcharht}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {scaledfontcharic}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {scaledfontcharta}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {scaledfontcharwd}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {scaledfontdimen}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {scaledinterwordshrink}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {scaledinterwordspace}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {scaledinterwordstretch}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {scaledmathstyle}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {scaledslantperpoint}}]
% \stopnewprimitive

\startnewprimitive[title={\prm {scantextokens}}]

This primitive scans the input as if it comes from a file. In the next examples
the \prm {detokenize} primitive turns tokenized code into verbatim code that is
similar to what is read from a file.

\startbuffer
\edef\whatever{\detokenize{This is {\bf bold} and this is not.}}
\detokenize   {This is {\bf bold} and this is not.}\crlf
\scantextokens{This is {\bf bold} and this is not.}\crlf
\scantextokens{\whatever}\crlf
\scantextokens\expandafter{\whatever}\par
\stopbuffer

\typebuffer

This primitive does not have the end|-|of|-|file side effects of its precursor
\prm {scantokens}.

{\getbuffer}

\stopnewprimitive

\startoldprimitive[title={\prm {scantokens}}]

Just forget about this \ETEX\ primnitive, just take the one in the next section.

\stopoldprimitive

% \startoldprimitive[title={\prm {scriptfont}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {scriptscriptfont}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {scriptscriptstyle}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {scriptspace}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {scriptstyle}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {scrollmode}}]
%     TODO
% \stopoldprimitive

% \startnewprimitive[title={\prm {semiexpand}}]
%     TODO
% \stopnewprimitive

% \startnewprimitive[title={\prm {semiexpanded}}]
%     TODO
% \stopnewprimitive

% \startnewprimitive[title={\prm {semiprotected}}]
%     TODO
% \stopnewprimitive

% \startoldprimitive[title={\prm {setbox}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {setdefaultmathcodes}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {setfontid}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {setlanguage}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {setmathatomrule}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {setmathdisplaypostpenalty}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {setmathdisplayprepenalty}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {setmathignore}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {setmathoptions}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {setmathpostpenalty}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {setmathprepenalty}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {setmathspacing}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {sfcode}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {shapingpenaltiesmode}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {shapingpenalty}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {shipout}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {shortinlinemaththreshold}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {shortinlineorphanpenalty}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {show}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {showbox}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {showboxbreadth}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {showboxdepth}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {showgroups}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {showifs}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {showlists}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {shownodedetails}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {showthe}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {showtokens}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {singlelinepenalty}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {skewchar}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {skip}}]
%     TODO
% \stopoldprimitive

% \startoldprimitive[title={\prm {skipdef}}]
%     TODO
% \stopoldprimitive

% \startnewprimitive[title={\prm {snapshotpar}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {spacefactor}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {spacefactormode}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {spacefactorshrinklimit}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {spacefactorstretchlimit}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {spaceskip}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {span}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {splitbotmark}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {splitbotmarks}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {splitdiscards}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {splitfirstmark}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {splitfirstmarks}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {splitmaxdepth}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {splittopskip}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {srule}}]
% \stopnewprimitive

\startoldprimitive[title={\prm {string}}]

We mention this original primitive because of the one in the next section. It
expands the next token or control sequence as if it was just entered, so normally
a control sequence becomes a backslash followed by characters and a space.

\stopoldprimitive

% \startnewprimitive[title={\prm {supmarkmode}}]
% \stopnewprimitive

\startnewprimitive[title={\prm {swapcsvalues}}]

Because we mention some \type {def} and \type {let} primitives here, it makes
sense to also mention a primitive that will swap two values (meanings). This one
has to be used with care. Of course that what gets swapped has to be of the same
type (or at least similar enough not to cause issues). Registers for instance
store their values in the token, but as soon as we are dealing with token lists
we also need to keep an eye on reference counting. So, to some extend this is
an experimental feature.

\stopnewprimitive

% \startnewprimitive[title={\prm {tabsize}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {tabskip}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {textdirection}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {textfont}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {textstyle}}]
% \stopoldprimitive

\startoldprimitive[title={\prm {the}}]

The \prm {the} primitive serializes the following token, when applicable:
integers, dimensions, token registers, special quantities, etc. The catcodes of
the result will be according to the current settings, so in \type {\the \dimen0},
the \type {pt} will have catcode \quote {letter} and the number and period will
become \quote {other}.

\stopoldprimitive

\startnewprimitive[title={\prm {thewithoutunit}}]

The \prm{the} primitive, when applied to a dimension variable, adds a \type {pt}
unit. because dimensions are the only traditional unit with a fractional part
they are sometimes used as pseudo floats in which case \prm {thewithoutunit} can
be used to avoid the unit. This is more convenient than stripping it off
afterwards (via an expandable macro).

\stopnewprimitive

% \startoldprimitive[title={\prm {thickmuskip}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {thinmuskip}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {time}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {tinymuskip}}]
% \stopnewprimitive

\startnewprimitive[title={\prm {todimension}}]

\startbuffer
\scratchdimen = 1234pt \todimension\scratchdimen
\stopbuffer

The following code gives this: {\nospacing\inlinebuffer} and like its numeric
counterparts accepts anything that resembles a number this one goes beyond
(user, internal or pseudo) registers values too.

\typebuffer

\stopnewprimitive

\startnewprimitive[title={\prm {tohexadecimal}}]

\startbuffer
\scratchcounter = 1234 \tohexadecimal\scratchcounter
\stopbuffer

The following code gives this: {\nospacing\inlinebuffer} with uppercase letters.

\typebuffer

\stopnewprimitive

\startnewprimitive[title={\prm {tointeger}}]

\startbuffer
\scratchcounter = 1234 \tointeger\scratchcounter
\stopbuffer

The following code gives this: {\nospacing\inlinebuffer} and is equivalent to
\prm {number}.

\typebuffer

\stopnewprimitive

\startnewprimitive[title={\prm {tokenized}}]

Just as \prm {expanded} has a counterpart \prm {unexpanded}, it makes sense to give
\prm {detokenize} a companion:

\startbuffer
\edef\foo{\detokenize{\inframed{foo}}}
\edef\oof{\detokenize{\inframed{oof}}}

\meaning\foo \crlf \dontleavehmode\foo

\edef\foo{\tokenized{\foo\foo}}

\meaning\foo \crlf \dontleavehmode\foo

\dontleavehmode\tokenized{\foo\oof}
\stopbuffer

\typebuffer {\tttf \getbuffer}

This primitive is similar to:

\starttyping
\def\tokenized#1{\scantextokens\expandafter{\normalexpanded{#1}}}
\stoptyping

and should be more efficient, not that it matters much as we don't use it that
much (if at all).

\stopnewprimitive

% \startoldprimitive[title={\prm {toks}}]
%     TODO
% \stopoldprimitive

\startnewprimitive[title={\prm {toksapp}}]

One way to append something to a token list is the following:

\starttyping
\scratchtoks\expandafter{\the\scratchtoks more stuff}
\stoptyping

This works all right, but it involves a copy of what is already in \type
{\scratchtoks}. This is seldom a real issue unless we have large token lists and
many appends. This is why \LUATEX\ introduced:

\starttyping
\toksapp\scratchtoks{more stuff}
\toksapp\scratchtoksone\scratchtokstwo
\stoptyping

At some point, when working on \LUAMETATEX, I realized that primitives like this
one and the next appenders and prependers to be discussed were always on the
radar of Taco and me. Some were even implemented in what we called \type {eetex}:
extended \ETEX, and we even found back the prototypes, dating from pre|-|\PDFTEX\
times.

\stopnewprimitive

% \startoldprimitive[title={\prm {toksdef}}]
%     TODO
% \stopoldprimitive

\startnewprimitive[title={\prm {tokspre}}]

Where appending something is easy because of the possible \prm {expandafter}
trickery a prepend would involve more work, either using temporary token
registers and|/|or using a mixture of the (no)expansion added by \ETEX, but all
are kind of inefficient and cumbersome.

\starttyping
\tokspre\scratchtoks{less stuff}
\tokspre\scratchtoksone\scratchtokstwo
\stoptyping

This prepends the token list that is provided.

\stopnewprimitive

% \startoldprimitive[title={\prm {tolerance}}]
% \stopoldprimitive

\startnewprimitive[title={\prm {tolerant}}]

This prefix tags the following macro as being tolerant with respect to the
expected arguments. It only makes sense when delimited arguments are used or when
braces are mandate.

\startbuffer
\tolerant\def\foo[#1]#*[#2]{(#1)(#2)}
\stopbuffer

\typebuffer \getbuffer

This definition makes \type {\foo} tolerant for various calls:

\startbuffer
\foo \foo[1] \foo [1] \foo[1] [2] \foo [1] [2]
\stopbuffer

\typebuffer

these give: \inlinebuffer. The spaces after the first call disappear because the
macro name parser gobbles it, while in the second case the \type {#*} gobbles
them. Here is a variant:

\startbuffer
\tolerant\def\foo[#1]#,[#2]{!#1!#2!}

\foo[?] x
\foo[?] [?] x

\tolerant\def\foo[#1]#*[#2]{!#1!#2!}

\foo[?] x
\foo[?] [?] x
\stopbuffer

\typebuffer

We now get the following:

\getbuffer

Here the \type {#,} remembers that spaces were gobbles and they will be put back
when there is no further match. These are just a few examples of this tolerant
feature. More details can be found in the lowlevel manuals.

\stopnewprimitive

% \startnewprimitive[title={\prm {tomathstyle}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {topmark}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {topmarks}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {topskip}}]
% \stopoldprimitive

\startnewprimitive[title={\prm {toscaled}}]

\startbuffer
\scratchdimen = 1234pt \toscaled\scratchdimen
\stopbuffer

The following code gives this: {\nospacing\inlinebuffer} is similar to \prm
{todimension} but omits the \type {pt} so that we don't need to revert to some
nasty stripping code.

\typebuffer

\stopnewprimitive

\startnewprimitive[title={\prm {tosparsedimension}}]

\startbuffer
\scratchdimen = 1234pt \tosparsedimension\scratchdimen
\stopbuffer

The following code gives this: {\nospacing\inlinebuffer} where \quote {sparse}
indicates that redundant trailing zeros are not shown.

\typebuffer

\stopnewprimitive

\startnewprimitive[title={\prm {tosparsescaled}}]

\startbuffer
\scratchdimen = 1234pt \tosparsescaled\scratchdimen
\stopbuffer

The following code gives this: {\nospacing\inlinebuffer} where \quote {sparse}
means that redundant trailing zeros are omitted.

\typebuffer

\stopnewprimitive

% \startnewprimitive[title={\prm {tpack}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {tracingadjusts}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {tracingalignments}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {tracingassigns}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {tracingcommands}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {tracingexpressions}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {tracingfonts}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {tracingfullboxes}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {tracinggroups}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {tracinghyphenation}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {tracingifs}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {tracinginserts}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {tracinglevels}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {tracinglists}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {tracinglostchars}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {tracingmacros}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {tracingmarks}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {tracingmath}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {tracingnesting}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {tracingnodes}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {tracingonline}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {tracingoutput}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {tracingpages}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {tracingparagraphs}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {tracingpasses}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {tracingpenalties}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {tracingrestores}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {tracingstats}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {tsplit}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {uccode}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {uchyph}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {uleaders}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {unboundary}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {undent}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {underline}}]
% \stopoldprimitive

\startoldprimitive[title={\prm {unexpanded}}]

This is an \ETEX\ enhancement. The content will not be expanded in a context
where expansion is happening, like in an \prm {edef}. In \CONTEXT\ you need to
use \prm {normalunexpanded} because we already had a macro with that name.

\startbuffer
\def \A{!}                       \meaning\A
\def \B{?}                       \meaning\B
\edef\C{\A\B}                    \meaning\C
\edef\C{\normalunexpanded{\A}\B} \meaning\C
\stopbuffer

\typebuffer

\startlines \tttf \getbuffer \stoplines

\stopoldprimitive

\startnewprimitive[title={\prm {unexpandedendless}}]

This one loops forever so you need to quit explicitly.

\stopnewprimitive

\startnewprimitive[title={\prm {unexpandedloop}}]

As follow up on \prm {expandedloop} we now show its counterpart:

\startbuffer
\edef\whatever
  {\unexpandedloop 1 10 1
     {\scratchcounter=\the\currentloopiterator\relax}}

\meaningasis\whatever
\stopbuffer

\typebuffer

\start \veryraggedright \tt\tfx \getbuffer \stop \blank

The difference between the (un)expanded loops and a local controlled
one is shown here. Watch the out of order injection of \type {A}'s.

\startbuffer
\edef\TestA{\localcontrolledloop 1 5 1 {A}} % out of order
\edef\TestB{\expandedloop        1 5 1 {B}}
\edef\TestC{\unexpandedloop      1 5 1 {C\relax}}
\stopbuffer

\typebuffer \getbuffer

We show the effective definition as well as the outcome of using them

\startbuffer
\meaningasis\TestA
\meaningasis\TestB
\meaningasis\TestC

A: \TestA
B: \TestB
C: \TestC
\stopbuffer

\typebuffer \startlines \tttf \getbuffer \stoplines

Watch how because it is empty \type {\TestA} has become a constant macro because
that's what deep down empty boils down to.

\stopnewprimitive

\startnewprimitive[title={\prm {unexpandedrepeat}}]

This one takes one instead of three arguments which looks better in simple loops.

\stopnewprimitive

% \startoldprimitive[title={\prm {unhbox}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {unhcopy}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {unhpack}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {unkern}}]
% \stopoldprimitive

\startoldprimitive[title={\prm {unless}}]

This \ETEX\ prefix will negate the test (when applicable).

\starttyping
       \ifx\one\two YES\else NO\fi
\unless\ifx\one\two NO\else YES\fi
\stoptyping

This primitive is hardly used in \CONTEXT\ and we probably could get rid of these
few cases.

\stopoldprimitive

\startnewprimitive[title={\prm {unletfrozen}}]

A frozen macro cannot be redefined: you get an error. But as nothing in \TEX\ is set
in stone, you can do this:

\starttyping
\frozen\def\MyMacro{...}
\unletfrozen\MyMacro
\stoptyping

and \type {\MyMacro} is no longer protected from overloading. It is still
undecided to what extend \CONTEXT\ will use this feature.

\stopnewprimitive

\startnewprimitive[title={\prm {unletprotected}}]

The complementary operation of \prm {letprotected} can be used to unprotect
a macro, so that it gets expandable.

\startbuffer
               \def  \MyMacroA{alpha}
\protected     \def  \MyMacroB{beta}
               \edef \MyMacroC{\MyMacroA\MyMacroB}
\unletprotected      \MyMacroB
               \edef \MyMacroD{\MyMacroA\MyMacroB}
\meaning             \MyMacroC\crlf
\meaning             \MyMacroD\par
\stopbuffer

\typebuffer

Compare this with the example in the previous section:

{\tttf \getbuffer}

\stopnewprimitive

% \startoldprimitive[title={\prm {unpenalty}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {unskip}}]
% \stopoldprimitive

\startnewprimitive[title={\prm {untraced}}]

Related to the meaning providers is the \prm {untraced} prefix. It marks a macro
as to be reported by name only. It makes the macro look like a primitive.

\starttyping
         \def\foo{}
\untraced\def\oof{}

\scratchtoks{\foo\foo\oof\oof}

\tracingall \the\scratchtoks \tracingnone
\stoptyping

This will show up in the log as follows:

\starttyping
1:4: {\the}
1:5: \foo ->
1:5: \foo ->
1:5: \oof
1:5: \oof
\stoptyping

This is again a trick to avoid too much clutter in a log. Often it doesn't matter
to users what the meaning of a macro is (if they trace at all). \footnote {An
earlier variant could also hide the expansion completely but that was just
confusing.}

\stopnewprimitive

% \startoldprimitive[title={\prm {unvbox}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {unvcopy}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {unvpack}}]
% \stopnewprimitive

\startoldprimitive[title={\prm {uppercase}}]

See its counterpart \prm {lowercase} for an explanation.

\stopoldprimitive

% \startoldprimitive[title={\prm {vadjust}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {valign}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {variablefam}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {vbadness}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {vbox}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {vcenter}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {vfil}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {vfill}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {vfilneg}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {vfuzz}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {virtualhrule}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {virtualvrule}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {vkern}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {vpack}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {vpenalty}}]
% \stopnewprimitive

% \startoldprimitive[title={\prm {vrule}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {vsize}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {vskip}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {vsplit}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {vss}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {vtop}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {wd}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {widowpenalties}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {widowpenalty}}]
% \stopoldprimitive

% \startnewprimitive[title={\prm {wordboundary}}]
% \stopnewprimitive

% \startnewprimitive[title={\prm {wrapuppar}}]
% \stopnewprimitive

\startoldprimitive[title={\prm {xdef}}]

This is an alternative for \type {\global \edef}:

\starttyping
\xdef\MyMacro{...}
\stoptyping

\stopoldprimitive

\startnewprimitive[title={\prm {xdefcsname}}]

This is the companion of \prm {xdef}:

\starttyping
\expandafter\xdef\csname MyMacro:1\endcsname{...}
             \xdefcsname MyMacro:1\endcsname{...}
\stoptyping

\stopnewprimitive

% \startoldprimitive[title={\prm {xleaders}}]
% \stopoldprimitive

% \startoldprimitive[title={\prm {xspaceskip}}]
% \stopoldprimitive

\startnewprimitive[title={\prm {xtoks}}]

This is the global variant of \prm {etoks}.

\stopnewprimitive

\startnewprimitive[title={\prm {xtoksapp}}]

This is the global variant of \prm {etoksapp}.

\stopnewprimitive

\startnewprimitive[title={\prm {xtokspre}}]

This is the global variant of \prm {etokspre}.

\stopnewprimitive

% \startoldprimitive[title={\prm {year}}]
% \stopoldprimitive

\stopsubject

\startsubject[title=Obsolete]

The \LUAMETATEX\ engine has more than its \LUATEX\ ancestor but it also has less.
Because in the end the local control mechanism performed quite okay I decided to
drop the \prm {immediateassignment} and \prm {immediateassigned} variants. They
sort of used the same trick so there isn't much to gain and it was less generic
(read: error prone).

% \startnewprimitive[title={\prm {immediateassignment}}]
%
% Assignments are not expandable which means that you cannot define fully
% expandable macros that have assignments. But, there is a way out of this:
%
% \startbuffer
% \scratchcounter = 10
% \edef\whatever{%
%     (\the\scratchcounter)
%     \immediateassignment\scratchcounter\numexpr\scratchcounter+10\relax
%     \immediateassignment\advance\scratchcounter -5
%     (\the\scratchcounter)
% }
% \meaning\whatever
% \stopbuffer
%
% \typebuffer
%
% Don't expect miracles: you can't mix|-|in content or unexpandable tokens as they
% will either show up or quit the scanning.
%
% {\getbuffer}
%
% \stopnewprimitive
%
% \startnewprimitive[title={\prm {immediateassigned}}]
%
% This is the multi|-|token variant of the primitive mentioned in the previous
% section.
%
% \startbuffer
% \scratchcounter = 10
% \edef\whatever{%
%     (\the\scratchcounter)
%     \immediateassigned{
%         \scratchcounter\numexpr\scratchcounter+10\relax
%         \advance\scratchcounter -5
%     }%
%     (\the\scratchcounter)
% }
% \meaning\whatever
% \stopbuffer
%
% \typebuffer
%
% The results are the same as in the previous section:
%
% {\getbuffer}
%
% \stopnewprimitive

\stopsubject

\page

% % It doesn't make sense to typeset this, also because it makes me feel old.
%
% \startsubject[title=A few notes on extensions] % ,placeholder=todo]
%
% This is a companion to the regular \LUAMETATEX\ reference manual, which is mostly
% a concise summary of the program and its features. They don't replace each other,
% and none of them claims completeness. There might be more manuals that discuss
% specific kind of extensions in the future. First some comments on extensions.
%
% The starting point of all \TEX\ engines is \TEX. The first follow up was \TEX\
% with support for 8 bit and languages. After that it took some time, but then two
% projects started that extended \TEX: \ETEX\ and \OMEGA. In the end the first
% brought some extensions to the macro machinery, more registers, a simple right to
% left typesetting feature, some more tracing, etc. The second was more ambitious
% and has input translation mechanisms, larger fonts, and multi directional
% typesetting. By the time \ETEX\ became stable, the \PDFTEX\ engine had showed up
% and at some point it integrated \ETEX. But \PDFTEX\ itself also extended the
% several components that make up \TEX. The \NTS\ project was started as follow up
% on \ETEX\ but although an engine written in \JAVA\ was the result it never was
% used for extensions; this project was fully funded by the german language user
% group.
%
% The \CONTEXT\ macro package was an early adopter of the \ETEX\ and \PDFTEX\
% extensions. Probably the most significant effect was that we got more registers
% (some other features were already kind of present in macro form). In between
% these engines we played with \type {eetex} (extended \ETEX) because we had some
% wishes of our own. We also explored extensions to the \DVI\ format but in the end
% \PDF\ won that race. An example of a new mechanism that we introduced in
% \CONTEXT\ was position tracking: marking positions that can be saved when the
% output is created and used in a second run. This started as a \DVI\ postprocessor
% in \PERL\ written by me, later turned into a \CLANGUAGE\ program by Taco, and
% eventually integrated in \PDFTEX\ by Thanh (\PDFTEX\ was a phd project). At some
% point \XETEX\ was developed, funded and driven by an organization that did high
% end multi lingual typesetting; it was based on \ETEX\ and uses a \DVI\ to \PDF\
% backend processor. Both \PDFTEX\ and \XETEX\ are supported by \CONTEXT\ \MKII,
% and both engines are basically stable and frozen.
%
% At some point Hartmut and I started playing with \LUA\ in \PDFTEX\ but soon Taco,
% Hartmut and I decided to start a follow up project. All the work on \LUATEX\ (and
% later \LUAMETATEX) is done whenever there is time and without financial
% compensation, so we have a slow but steady development track. Early in the
% \LUATEX\ development there has been some funding for the initial transition (by
% Taco) from \PDFTEX\ to what became the early versions of \LUATEX . You can read
% more about the oriental \TEX\ project in other documents and articles in user
% group journals. There has been some funded development of a library subsystem
% (which for some reason never took off) as well as \LUAJIT\ integration (by
% Luigi). The initial \METAPOST\ library (also done by Taco) was funded by a couple
% of user groups. Then there are the (ongoing) font projects by GUST that got
% funded by user groups as these were much needed for the \UNICODE\ engines.
%
% After the jump start, most work was and is still done in the usual \TEX\ spirit,
% on a voluntary basis, by folks from the \CONTEXT\ community, and after a decades
% we reached the stable version 1.00. It's one of the engines in \TEXLIVE\ and
% Luigi makes sure it integrates well in there. We did continue and around 1.10 the
% more of less final version was reached and \LUAMETATEX\ took off. In \LUATEX\
% only bugs get fixed, occasionally some helpers can get added, and we might port
% some of \LUAMETATEX\ back to its parent, when it doesn't harm compatibility.
%
% Already early in development some primitives were added that enhance the macro
% language. More were added later. It's these extensions that are discussed in this
% document. There are several documents in the \CONTEXT\ distribution that discuss
% the (ongoing) development, right from the start, and these often contain
% examples. For instance some of the new primitives have been introduced there,
% complete with a rationale and examples of usage.
%
% Just for the record: the \CONTEXT\ group runs the build farm that is used to
% generate binaries for all sorts of platforms. We make sure that there are always
% versions that can be used for real production jobs. You can expect regular
% updates as long as there are developments (of course, eventually we're done).
%
% \stopsubject

\startsubject[title=Rationale] % ,placeholder=todo]

Some words about the why and how it came. One of the early adopters of \CONTEXT\
was Taco Hoekwater and we spent numerous trips to \TEX\ meetings all over the
globe. He was also the only one I knew who had read the \TEX\ sources. Because
\CONTEXT\ has always been on the edge of what is possible and at that time we
both used it for rather advanced rendering, we also ran into the limitations. I'm
not talking of \TEX\ features here. Naturally old school \TEX\ is not really
geared for dealing with images of all kind, colors in all kind of color spaces,
highly interactive documents, input methods like \XML, etc. The nice thing is
that it offers some escapes, like specials and writes and later execution of
programs that opened up lots of possibilities, so in practice there were no real
limitations to what one could do. But coming up with a consistent and extensible
(multi lingual) user interface was non trivial, because it had an impact in
memory usage and performance. A lot could be done given some programming, as
\CONTEXT\ \MKII\ proves, but it was not always pretty under the hood. The move to
\LUATEX\ and \MKIV\ transferred some action to \LUA, and because \LUATEX\
effectively was a \CONTEXT\ related project, we could easily keep them in sync.

Our traveling together, meeting several times per year, and eventually email and
intense \LUATEX\ developments (lots of Skype sessions) for a couple of years,
gave us enough opportunity to discuss all kind of nice features not present in
the engine. The previous century we discussed lots of them, rejected some, stayed
with others, and I admit that forgot about most of the arguments already. Some
that we did was already explored in \type {eetex}, some of those ended up in
\LUATEX, and eventually what we have in \LUAMETATEX\ can been seen as the result
of years of programming in \TEX, improving macros, getting more performance and
efficiency out of existing \CONTEXT\ code and inspiration that we got out of the
\CONTEXT\ community, a demanding lot, always willing to experiment with us.

Once I decided to work on \LUAMETATEX\ and bind its source to the \CONTEXT\
distribution so that we can be sure that it won't get messed up and might
interfere with the \CONTEXT\ expectations, some more primitives saw their way
into it. It is very easy to come up with all kind of bells and whistles but it is
equally easy to hurt performance of an engine and what might go unnoticed in
simple tests can really affect a macro package that depends on stability. So, what
I did was mostly looking at the \CONTEXT\ code and wondering how to make some of
the low level macros look more natural, also because I know that there are users
who look into these sources. We spend a lot of time making them look consistent
and nice and the nicer the better. Getting a better performance was seldom an
argument because much is already as fast as can be so there is not that much to
gain, but less clutter in tracing was an argument for some new primitives. Also,
the fact that we soon might need to fall back on our phones to use \TEX\ a
smaller memory footprint and less byte shuffling also was a consideration. The
\LUAMETATEX\ memory footprint is somewhat smaller than the \LUATEX\ footprint.
By binding \LUAMETATEX\ to \CONTEXT\ we can also guarantee that the combinations
works as expected.

I'm aware of the fact that \CONTEXT\ is in a somewhat unique position. First of
all it has always been kind of cutting edge so its users are willing to
experiment. There are users who immediately update and run tests, so bugs can and
will be fixed fast. Already for a long time the community has an convenient
infrastructure for updating and the build farm for generating binaries (also for
other engines) is running smoothly.

Then there is the \CONTEXT\ user interface that is quite consistent and permits
extensions with staying backward compatible. Sometimes users run into old manuals
or examples and then complain that \CONTEXT\ is not compatible but that then
involves obsolete technology: we no longer need font and input encodings and font
definitions are different for \OPENTYPE\ fonts. We always had an abstract backend
model, but nowadays \PDF\ is kind of dominant and drives a lot of expectations.
So, some of the \MKII\ commands are gone and \MKIV\ has some more. Also, as
\METAPOST\ evolved that department in \CONTEXT\ also evolved. Think of it like
cars: soon all are electric so one cannot expect a hole to poor in some fluid but
gets a (often incompatible) plug instead. And buttons became touch panels. There
is no need to use much force to steer or brake. Navigation is different, as are
many controls. And do we need to steer ourselves a decade from now?

So, just look at \TEX\ and \CONTEXT\ in the same way. A system from the nineties
in the previous century differs from one three decades later. Demands differ,
input differs, resources change, editing and processing moves on, and so on.
Manuals, although still being written are seldom read from cover to cover because
online searching replaced them. And who buys books about programming? So
\LUAMETATEX, while still being \TEX\ also moves on, as do the way we do our low
level coding. This makes sense because the original \TEX\ ecosystem was not made
with a huge and complex macro package in mind, that just happened. An author was
supposed to make a style for each document. An often used argument for using
another macro package over \CONTEXT\ was that the later evolved and other macro
packages would work the same forever and not change from the perspective of the
user. In retrospect those arguments were somewhat strange because the world,
computers, users etc.\ do change. Standards come and go, as do software politics
and preferences. In many aspects the \TEX\ community is not different from other
large software projects, operating system wars, library devotees, programming
language addicts, paradigm shifts. But, don't worry, if you don't like
\LUAMETATEX\ and its new primitives, just forget about them. The other engines
will be there forever and are a safe bet, although \LUATEX\ already stirred up
the pot I guess. But keep in mind that new features in the latest greatest
\CONTEXT\ version will more and more rely on \LUAMETATEX\ being used; after all
that is where it's made for. And this manual might help understand its users why,
where and how the low level code differs between \MKII, \MKIV\ and \LMTX.

Can we expect more new primitives than the ones introduced here? Given the amount
of time I spent on experimenting and considering what made sense and what not,
the answer probably is \quotation {no}, or at least \quotation {not that much}.
As in the past no user ever requested the kind of primitives that were added, I
don't expect users to come up with requests in the future either. Of course,
those more closely related to \CONTEXT\ development look at it from the other
end. Because it's there where the low level action really is, demands might still
evolve.

Basically there are wo areas where the engine can evolve: the programming part
and the rendering. In this manual we focus on the programming and writing the
manual sort of influences how details get filled in. Rendering in more complex
because there heuristics and usage plays a more dominant role. Good examples are
the math, par and page builder. They were extended and features were added over
time but improved rendering came later. Not all extensions are critical, some are
there (and got added) in order to write more readable code but there is only so
much one can do in that area. Occasionally a feature pops up that is a side
effect of a challenge. No matter what gets added it might not affect complexity
too much and definitely not impact performance significantly!

Hans Hagen \crlf Hasselt NL

\stopsubject

\popoverloadmode

\startluacode
    local match = string.match
    local find  = string.match

    function document.CheckCompleteness()
        local primitives = token.getprimitives()
        local luametatex = { }
        local indexed    = { }

        for i=1,#primitives do
            local p = primitives[i]
            if p[4] == 4 then
                local name = p[3]
                if find(name,"U") or find (name,"math") then
                    -- ignore
                    luametatex[name] = nil
                else
                    luametatex[name] = false
                end
            end
        end

        local function collect(index)
            if index then
                local data = index.entries
                for i=1,#data do
                    local name = match(data[i].list[1][1],"\\tex%s*{(.-)}") or ""
                    if luametatex[name] == false then
                        luametatex[name] = true
                    end
                    indexed[name] = true
                end
            end
        end

        collect(structures.registers.collected and structures.registers.collected.index)

        context.startsubject { title = "To be checked primitives" }

        context.blank()
        context.startcolumns { n = 2 }
        for k, v in table.sortedhash(luametatex) do
            if not v then
                context.dontleavehmode()
                context.type(k)
                context.crlf()
            end
        end
        context.stopcolumns()

        context.page()

        context.stopsubject()

        context.startsubject { title = "Indexed primitives" }

        context.blank()
        context.startcolumns { n = 2 }
        for k, v in table.sortedhash(indexed) do
            context.dontleavehmode()
            if luametatex[k] == true then
                context("\\color[darkgreen]{\\tttf %s}",k)
            elseif luametatex[k] == false then
                context("\\color[darkred]{\\tttf %s}",k)
            else
                context("{\\tttf %s}",k)
            end
            context.crlf()
        end
        context.stopcolumns()

        context.page()

        context.stopsubject()
    end
\stopluacode

\startmode[atpragma]
    \startluacode
        context.page()
        document.CheckCompleteness()
    \stopluacode

%     Run \type {s-system-syntax.mkxl} for a complete overview of the \LUAMETATEX\
%     primitives.
\stopmode

\stopbodymatter

\stoptext
